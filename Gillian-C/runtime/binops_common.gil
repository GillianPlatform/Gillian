#internal

proc i__binop_cmpl_le(v1, v2) {
        goto [ l-nth(v1, 0.) = "long" ] llon unde;
  llon: goto [ l-nth(v2, 0.) = "long" ] blon unde;
  blon: ret := "i__value_of_bool"(l-nth(v1, 1.) <= l-nth(v2, 1.));
        return;
  unde: fail[comparison]("Using long comparison operator for non-long elements")
};

proc i__binop_cmpl_lt(v1, v2) {
        goto [ l-nth(v1, 0.) = "long" ] llon unde;
  llon: goto [ l-nth(v2, 0.) = "long" ] blon unde;
  blon: ret := "i__value_of_bool"(l-nth(v1, 1.) < l-nth(v2, 1.));
        return;
  unde: fail[comparison]("Using long comparison operator for non-long elements")
};

proc i__binop_cmpl_ge(v1, v2) {
        goto [ l-nth(v1, 0.) = "long" ] llon unde;
  llon: goto [ l-nth(v2, 0.) = "long" ] blon unde;
  blon: ret := "i__value_of_bool"(not (l-nth(v1, 1.) < l-nth(v2, 1.)));
        return;
  unde: fail[comparison]("Using long comparison operator for non-long elements")
};

proc i__binop_cmpl_eq(v1, v2) {
        goto [ l-nth(v1, 0.) = "long" ] llon unde;
  llon: goto [ l-nth(v2, 0.) = "long" ] blon unde;
  blon: ret := "i__value_of_bool"(l-nth(v1, 1.) < l-nth(v2, 1.));
        return;
  unde: fail[comparison]("Using long comparison operator for non-long elements")
};

proc i__binop_cmpu_gt(v1, v2) {
      ir := "i__binop_cmpu_le"(v1, v2);
      ret := "i__neg_bool_value"(ir);
      return
};

proc i__binop_cmpfs_ge(v1, v2) {
        goto [ l-nth(v1, 0.) = "single" ] llon unde;
  llon: goto [ l-nth(v2, 0.) = "single" ] blon unde;
  blon: ret := "i__value_of_bool"(not (l-nth(v1, 1.) < l-nth(v2, 1.)));
        return;
  unde: fail[comparison]("Using single comparison operator for non-single elements")
};

proc i__binop_cmpfs_le(v1, v2) {
        goto [ l-nth(v1, 0.) = "single" ] llon unde;
  llon: goto [ l-nth(v2, 0.) = "single" ] blon unde;
  blon: ret := "i__value_of_bool"(l-nth(v1, 1.) <= l-nth(v2, 1.));
        return;
  unde: fail[comparison]("Using single comparison operator for non-single elements")
};

proc i__binop_cmpu_ne(v1, v2) {
        ir := "i__binop_cmpu_eq"(v1, v2);
        ret := "i__neg_bool_value"(ir);
        return
};

proc i__binop_cmplu_ne(v1, v2) {
      ir := "i__binop_cmplu_eq"(v1, v2);
      ret := "i__neg_bool_value"(ir);
      return
};

proc i__binop_cmp_gt(v1, v2) {
        goto [ l-nth(v1, 0.) = "int" ] llon unde;
  llon: goto [ l-nth(v2, 0.) = "int" ] blon unde;
  blon: ret := "i__value_of_bool"(l-nth(v1, 1.) > l-nth(v2, 1.));
        return;
  unde: fail[comparison]("Using int comparison operator for non-int elements")
};

proc i__binop_cmp_ge(v1, v2) {
        goto [ l-nth(v1, 0.) = "int" ] llon unde;
  llon: goto [ l-nth(v2, 0.) = "int" ] blon unde;
  blon: ret := "i__value_of_bool"(l-nth(v1, 1.) >= l-nth(v2, 1.));
        return;
  unde: fail[comparison]("Using int comparison operator for non-int elements")
};

proc i__binop_cmp_le(v1, v2) {
        goto [ l-nth(v1, 0.) = "int" ] llon unde;
  llon: goto [ l-nth(v2, 0.) = "int" ] blon unde;
  blon: ret := "i__value_of_bool"(l-nth(v1, 1.) <= l-nth(v2, 1.));
        return;
  unde: fail[comparison]("Using int comparison operator for non-int elements")
};

proc i__binop_cmp_lt(v1, v2) {
        goto [ l-nth(v1, 0.) = "int" ] llon unde;
  llon: goto [ l-nth(v2, 0.) = "int" ] blon unde;
  blon: ret := "i__value_of_bool"(l-nth(v1, 1.) < l-nth(v2, 1.));
        return;
  unde: fail[comparison]("Using int comparison operator for non-int elements")
};

proc i__binop_cmp_eq(v1, v2) {
        goto [ l-nth(v1, 0.) = "int" ] llon unde;
  llon: goto [ l-nth(v2, 0.) = "int" ] blon unde;
  blon: ret := "i__value_of_bool"(l-nth(v1, 1.) = l-nth(v2, 1.));
        return;
  unde: fail[comparison]("Using int comparison operator for non-int elements")
};

proc i__binop_cmp_ne(v1, v2) {
        ir := "i__binop_cmp_eq"(v1, v2);
        ret := "i__neg_bool_value"(ir);
        return
};

proc i__binop_mull(v1, v2) {
        goto [ l-nth(v1, 0.) = "long" ] llon unde;
  llon: goto [ l-nth(v2, 0.) = "long" ] blon unde;
  blon: ret := {{ "long", l-nth(v1, 1.) * l-nth(v2, 1.) }};
        return;
  unde: fail[operator]("Using *l operator for non-long elements")
};

proc unsigned(n) {
      max_size := 18446744073709551615;
      ret := n % max_size;
      ret := ret + max_size;
      ret := ret % max_size;
      fail [unsigned] ("unsigned");
      (* ret := ((n % max_size) + max_size) % max_size; *)
      return
};

proc i__binop_divlu(v1, v2) {
        goto [ l-nth(v1, 0.) = "long" ] llon unde;
  llon: goto [ l-nth(v2, 0.) = "long" ] blon unde;
        assert (! (l-nth(v2, 1.) == 0.));
  blon: ret := {{ "long", m_floor(l-nth(v1, 1.) / l-nth(v2, 1.)) }};
        return;
  unde: fail[operator]("Using /lu operator for non-long elements")
};

proc i__binop_divl(v1, v2) {
        goto [ l-nth(v1, 0.) = "long" ] llon unde;
  llon: goto [ l-nth(v2, 0.) = "long" ] blon unde;
        assert (! (l-nth(v2, 1.) == 0.));
  blon: ret := {{ "long", m_floor(l-nth(v1, 1.) / l-nth(v2, 1.)) }};
        return;
  unde: fail[operator]("Using /l operator for non-long elements")
};

proc i__binop_modlu(v1, v2) {
        goto [ l-nth(v1, 0.) = "long" ] llon unde;
  llon: goto [ l-nth(v2, 0.) = "long" ] blon unde;
        assert (! (l-nth(v2, 1.) == 0.));
  blon: ret := {{ "long", m_floor(l-nth(v1, 1.) % l-nth(v2, 1.)) }};
        return;
  unde: fail[operator]("Using %lu operator for non-long elements")
};

proc i__binop_mod(v1, v2) {
        goto [ l-nth(v1, 0.) = "int" ] llon unde;
  llon: goto [ l-nth(v2, 0.) = "int" ] blon unde;
        assert (! (l-nth(v2, 1.) == 0.));
  blon: ret := {{ "int", m_floor(l-nth(v1, 1.) % l-nth(v2, 1.)) }};
        return;
  unde: fail[operator]("Using % operator for non-int elements")
};

proc i__binop_mulfs(v1, v2) {
        goto [ l-nth(v1, 0.) = "single" ] llon unde;
  llon: goto [ l-nth(v2, 0.) = "single" ] blon unde;
  blon: ret := {{ "single", l-nth(v1, 1.) * l-nth(v2, 1.) }};
        return;
  unde: fail[operator]("Using *s operator for non-long elements")
};

proc i__binop_mul(v1, v2) {
        goto [ l-nth(v1, 0.) = "int" ] llon unde;
  llon: goto [ l-nth(v2, 0.) = "int" ] blon unde;
  blon: ret := {{ "int", l-nth(v1, 1.) * l-nth(v2, 1.) }};
        return;
  unde: fail[operator]("Using * operator for non-int elements")
};

proc i__binop_xor(v1, v2) {
        goto [ l-nth(v1, 0.) = "int" ] llon unde;
  llon: goto [ l-nth(v2, 0.) = "int" ] blon unde;
  blon: ret := {{ "int", l-nth(v1, 1.) ^ l-nth(v2, 1.) }};
        return;
  unde: fail[operator]("Using ^ operator for non-int elements")
};

proc i__binop_div(v1, v2) {
        goto [ l-nth(v1, 0.) = "int" ] llon unde;
  llon: goto [ l-nth(v2, 0.) = "int" ] blon unde;
        assert (! (l-nth(v2, 1.) == 0.));
  blon: ret := {{ "int", m_floor(l-nth(v1, 1.) / l-nth(v2, 1.)) }};
        return;
  unde: fail[operator]("Using /lu operator for non-int elements")
};

proc i__binop_and(v1, v2) {
        goto [ l-nth(v1, 0.) = "int" ] llon unde;
  llon: goto [ l-nth(v2, 0.) = "int" ] blon unde;
  blon: ret := {{ "int", l-nth(v1, 1.) & l-nth(v2, 1.) }};
        return;
  unde: fail[operator]("Using & operator for non-int elements")
};

proc i__binop_or(v1, v2) {
        goto [ l-nth(v1, 0.) = "int" ] llon unde;
  llon: goto [ l-nth(v2, 0.) = "int" ] blon unde;
  blon: ret := {{ "int", l-nth(v1, 1.) | l-nth(v2, 1.) }};
        return;
  unde: fail[operator]("Using | operator for non-int elements")
};

proc i__binop_shl(v1, v2) {
        goto [ l-nth(v1, 0.) = "int" ] llon unde;
  llon: goto [ l-nth(v2, 0.) = "int" ] blon unde;
  blon: ret := {{ "int", l-nth(v1, 1.) << l-nth(v2, 1.) }};
        return;
  unde: fail[operator]("Using << operator for non-int elements")
};

proc i__binop_shr(v1, v2) {
        goto [ l-nth(v1, 0.) = "int" ] llon unde;
  llon: goto [ l-nth(v2, 0.) = "int" ] blon unde;
  blon: ret := {{ "int", l-nth(v1, 1.) >> l-nth(v2, 1.) }};
        return;
  unde: fail[operator]("Using >> operator for non-int elements")
};

proc i__binop_shru(v1, v2) {
        goto [ l-nth(v1, 0.) = "int" ] llon unde;
  llon: goto [ l-nth(v2, 0.) = "int" ] blon unde;
  blon: ret := {{ "int", l-nth(v1, 1.) >>> l-nth(v2, 1.) }};
        return;
  unde: fail[operator]("Using >>> operator for non-int elements")
};

proc i__binop_andl(v1, v2) {
        goto [ l-nth(v1, 0.) = "long" ] llon unde;
  llon: goto [ l-nth(v2, 0.) = "long" ] blon unde;
  blon: ret := {{ "long", l-nth(v1, 1.) &l l-nth(v2, 1.) }};
        return;
  unde: fail[operator]("Using &l operator for non-long elements")
};

proc i__binop_shrlu(v1, v2) {
        goto [ l-nth(v1, 0.) = "long" ] llon unde;
  llon: goto [ l-nth(v2, 0.) = "int" ] blon unde;
  blon: ret := {{ "long", l-nth(v1, 1.) >>>l l-nth(v2, 1.) }};
        return;
  unde: fail[operator]("Using >>lu operator for non-long elements")
};

proc i__binop_shll(v1, v2) {
        goto [ l-nth(v1, 0.) = "long" ] llon unde;
  llon: goto [ l-nth(v2, 0.) = "int" ] blon unde;
  blon: ret := {{ "long", l-nth(v1, 1.) <<l l-nth(v2, 1.) }};
        return;
  unde: fail[operator]("Using <<l operator for non-long elements")
};

proc i__binop_orl(v1, v2) {
        goto [ l-nth(v1, 0.) = "long" ] llon unde;
  llon: goto [ l-nth(v2, 0.) = "long" ] blon unde;
  blon: ret := {{ "long", l-nth(v1, 1.) |l l-nth(v2, 1.) }};
        return;
  unde: fail[operator]("Using |l operator for non-long elements")
};

proc i__binop_xorl(v1, v2) {
        goto [ l-nth(v1, 0.) = "long" ] llon unde;
  llon: goto [ l-nth(v2, 0.) = "long" ] blon unde;
  blon: ret := {{ "long", l-nth(v1, 1.) ^l l-nth(v2, 1.) }};
        return;
  unde: fail[operator]("Using ^l operator for non-long elements")
};

proc i__binop_addf(v1, v2) {
        goto [ l-nth(v1, 0.) = "float" ] lint unde;
  lint: goto [ l-nth(v2, 0.) = "float" ] bint unde;
  bint: ret := {{ "float", l-nth(v1, 1.) + l-nth(v2, 1.) }};
        return;
  unde: ret := undefined;
        return
};

proc i__binop_divf(v1, v2) {
        goto [ l-nth(v1, 0.) = "float" ] llon unde;
  llon: goto [ l-nth(v2, 0.) = "float" ] blon unde;
        assert (! (l-nth(v2, 1.) == 0.));
  blon: ret := {{ "float", l-nth(v1, 1.) / l-nth(v2, 1.) }};
        return;
  unde: fail[operator]("Using /f operator for non-float elements")
};

proc i__binop_addfs(v1, v2) {
        goto [ l-nth(v1, 0.) = "single" ] llon unde;
  llon: goto [ l-nth(v2, 0.) = "single" ] blon unde;
        assert (! (l-nth(v2, 1.) == 0.));
  blon: ret := {{ "single", l-nth(v1, 1.) + l-nth(v2, 1.) }};
        return;
  unde: fail[operator]("Using +s operator for non-single elements")
};

proc i__binop_subfs(v1, v2) {
        goto [ l-nth(v1, 0.) = "single" ] llon unde;
  llon: goto [ l-nth(v2, 0.) = "single" ] blon unde;
        assert (! (l-nth(v2, 1.) == 0.));
  blon: ret := {{ "single", l-nth(v1, 1.) - l-nth(v2, 1.) }};
        return;
  unde: fail[operator]("Using -s operator for non-single elements")
};