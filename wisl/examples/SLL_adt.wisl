datatype MyList {
  Nil;
  Cons(Any, MyList)
}

pure function append(xs : MyList, x) {
  case xs {
    Nil         -> 'Cons(x, 'Nil);
    Cons(y, ys) -> 'Cons(y, append(ys, x))
  }
}

pure function length(xs : MyList) {
  case xs {
    Nil         -> 0;
    Cons(x, xs) -> 1 + length(xs)
  }
}

pure function double_length(xs : MyList) {
  case xs {
    Nil         -> 0;
    Cons(x, xs) -> 2 + length(xs)
  }
}

//
// Standard over-approximating sll predicate with contents
//
predicate sll(+x, vs) {
  // Empty sll
  (x == null) * (vs == 'Nil);
  // One sll node and the rest
  (x -b> #v, #next) * sll(#next, #vs) *
  (vs == 'Cons(#v, #vs))
}

// 00. Allocating an sll node with the given value
{ v == #v }
function sll_allocate_node(v){
  t := new(2);
  [t] := v;
  return t
}
{ sll(ret, 'Cons(#v, 'Nil)) }

// This incorrect spec should fail to verify
{ (v == #v) * (u == #u) }
function sll_allocate_node_fails(u, v){
  t := new(2);
  [t] := v;
  return t
}
{ sll(ret, 'Cons(#u, 'Nil)) }


//
// RECURSIVE sll MANIPULATION
//

// 01. Prepending a given value to a given sll
{ (x == #x) * (k == #k) * sll(#x, #vs) }
function sll_prepend(x, k){
    z := sll_allocate_node(k);
    [z + 1] := x;
    return z
}
{ sll(ret, 'Cons(#k, #vs)) }

// 02. Appending a given value to a given SLL
{ (x == #x) * (k == #k) * sll(#x, #vs) }
function sll_append(x, k){
  if (x = null) {
    x := sll_allocate_node(k)
    } else {
      t := [x + 1];
      z := sll_append(t, k);
      [x + 1] := z
  };
  return x
}
{ sll(ret,  append(#vs, #k)) }

// 06. Calculating the length of a given SLL
{ (x == #x) *  sll(#x, #vs) }
function sll_length(x) {
  n := 0;
  if (x = null){
    n := 0
  } else {
    t := [x + 1];
    n := sll_length(t);
    n := 1 + n
  };
  return n
}
{ ret == length(#vs) }

// This spec fails to verify
{ (x == #x) *  sll(#x, #vs) }
function sll_length_fails(x) {
  n := 0;
  if (x = null){
    n := 0
  } else {
    t := [x + 1];
    n := sll_length(t);
    n := 1 + n
  };
  return n
}
{ ret == double_length(#vs) }

// 05. Copying a given sll
{ (x == #x) * sll(#x, #vs) }
function sll_copy(x){
  y := null;
  if (not (x = null)) {
    k := [x];
    y := sll_allocate_node(k);
    t := [x + 1];
    z := sll_copy(t);
    [y + 1] := z
  } else {
    skip
  };
  return y
}
{ sll(#x, #vs) * sll(ret, #vs) }

// 10. Freeing a given sll
{ (x == #x) * sll(#x, #vs) }
function sll_free(x){
  if (x = null) {
    skip
  } else {
    t := [x + 1];
    z := sll_free(t);
    free(x)
  };
  return null
}
{ (ret == null) }
