// Over-approximating SLL predicate with contents, but no pointers
predicate SLL_ox(+x, vs) {
  // Empty SLL
  (x == null) * (vs == []);
  // One SLL node and the rest
  (x -b> #v, #next) * SLL_ox(#next, #vs) *
  (vs == #v :: #vs)
}

// Exact SLL predicate with pointers and contents
predicate SLL_ex(+x, ps, vs) {
  // Empty SLL
  (x == null) * (ps == []) * (vs == []);
  // One SLL node and the rest
  (x -b> #v, #next) * SLL_ex(#next, #ps, #vs) *
  (ps == x :: #ps) * (vs == #v :: #vs)
}

// Iterative correct list disposal
{ (x == #x) * SLL_ex(#x, #ps, #vs) }
function SLL_dispose_iter(x) {
  [[ invariant {bind: x, #rps, #rvs} SLL_ex(x, #rps, #rvs) ]];
  while (not (x = null)) {
    t := [x + 1];
    delete(x);
    x := t
  };
  return null
}
{ (ret == null) }

