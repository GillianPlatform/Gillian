
//
// Exact SLL predicate with pointers and contents
//
predicate SLL_ex(+x, ps, vs) {
  // Empty SLL
  (x == null) * (ps == []) * (vs == []);
  // One SLL node and the rest
  (x -b> #v, #next) * SLL_ex(#next, #ps, #vs) *
  (ps == x :: #ps) * (vs == #v :: #vs)
}

//
// Exact SLL segment predicate with pointers and contents
//
predicate SLLseg_ex(+x, +y, ps, vs) {
  (x == y) * (ps == []) * (vs == []);
  (x -b> #v, #next) * SLLseg_ex(#next, y, #ps, #vs) *
  (ps == x :: #ps) * (vs == #v :: #vs)
}

//
// Lemma: SLLseg segment concatenated with an SLL node is an SLLseg
//
lemma SSLseg_append {
  statement:
    forall x, y, ps, vs, v, z.
      SLLseg_ex(x, y, ps, vs) * (y -b> v, z) |- SLLseg_ex(x, z, ps @ [ y ], vs @ [ v ])

  proof:
    unfold SLLseg_ex(x, y, ps, vs);
    if (not (vs = [])) {
      assert {bind: #nv, #nnext, #nps, #nvs}
        (x -b> #nv, #nnext) * SLLseg_ex(#nnext, y, #nps, #nvs) *
        (ps == x :: #nps) * (vs == #nv :: #nvs);
      apply SSLseg_append(#nnext, y, #nps, #nvs, v, z)
    }
}

//
// Lemma: SLLseg concatenated with an SLL is an SLL
//
lemma SLLseg_concat_SLL {
  statement:
    forall x, y.
      SLLseg_ex(x, y, #px, #vx) * SLL_ex(y, #py, #vy) |- SLL_ex (x, #px @ #py, #vx @ #vy)

  proof:
    unfold SLLseg_ex(x, y, #px, #vx);
    if (not (#vx = [])){
      assert {bind: #nv, #nnext} (x -b> #nv, #nnext);
      apply SLLseg_concat_SLL(#nnext, y)
    }
}

//
// Pure predicate for list membership
//
predicate list_member(+vs, +k, r){
  (vs == null) * (r == false);
  (vs == k :: #rest) * (r == true);
  (vs == #v :: #rest) * (! (#v == k)) * list_member(#rest, k, r)
}

// Allocating an SLL node with the given value
{ v == #v }
function SLL_allocate_node(v) {
  x := new(2);
  [x] := v;
  return x
}
{ SLL_ex(ret, [ret], [ #v ]) }

//
// RECURSIVE SLL MANIPULATION
//

// Freeing a given SLL
{ (x == #x) * SLL_ex(#x, #ps, #vs) }
function SLL_free(x){
  if (x = null) {
    skip
  } else {
    t := [x + 1];
    z := SLL_free(t);
    free(x)
  };
  return null
}
{ (ret == null) }

// Prepending a given value to a given SLL
{ (x == #x) * (k == #k) * SLL_ex(#x, #ps, #vs) }
function SLL_prepend(x, k){
    z := SLL_allocate_node(k);
    [z + 1] := x;
    return z
}
{ SLL_ex(ret, #z :: #ps, #k :: #vs) }

// Appending a given value to a given SLL
{ (x == #x) * (k == #k) * SLL_ex(#x, #ps, #vs) }
function SLL_append(x, k){
  if (x = null) {
    x := SLL_allocate_node(k)
    } else {
      t := [x + 1];
      z := SLL_append(t, k);
      [x + 1] := z
  };
  return x
}
{ SLL_ex(ret, #ps @ [#np], #vs @ [#k]) }

// Concatenating two given SLLs
{(x == #x) * (y == #y) * SLL_ex(#x, #px, #vx) * SLL_ex(#y, #py, #vy) }
function SLL_concat(x, y) {
  if (x = null){
    x := y
  } else {
    t := [x + 1];
    z := SLL_concat(t, y);
    [x + 1] := z
  };
  return x
}
{SLL_ex(ret, #px @ #py, #vx @ #vy)}

// Copying a given SLL
{ (x == #x) * SLL_ex(#x, #ps, #vs) }
function SLL_copy(x){
  y := null;
  if (not (x = null)) {
    k := [x];
    y := SLL_allocate_node(k);
    t := [x + 1];
    z := SLL_copy(t);
    [y + 1] := z
  } else {
    skip
  };
  return y
}
{ SLL_ex(#x, #ps, #vs) * SLL_ex(ret, #nps, #vs) }

// Appending a given SLL node to a given SLL
{ (x == #x) * (y == #y) * SLL_ex(#x, #ps, #vs) * SLL_ex(#y, [#y], [#vy]) }
function SLL_append_node(x, y) {
  if (x = null) {
    x := y
  } else {
    t := [x + 1];
    z := SLL_append_node(t, y);
    [x + 1] := z
  };
  return x
}
{ SLL_ex(ret, #ps @ [#y], #vs @ [#vy]) }

// Reversing a given SLL
{ (x == #x) *  SLL_ex(#x, #ps, #vs) }
function SLL_reverse(x){
  if (not (x = null)) {
    t := [x + 1];
    [x + 1] := null;
    z := SLL_reverse(t);
    y := SLL_append_node(z, x)
  } else {
    y := null
  };
  return y
}
{ SLL_ex(ret, rev #ps, rev #vs) }

// Calculating the length of a given SLL
{ (x == #x) *  SLL_ex(#x, #ps, #vs) }
function SLL_length(x) {
  n := 0;
  if (x = null){
    n := 0
  } else {
    t := [x + 1];
    n := SLL_length(t);
    n := 1 + n
  };
  return n
}
{ ret == len #vs }

// Checking if a given value is in a given SLL
{ (x == #x) * (k == #k) * SLL_ex(#x, #ps, #vs) * list_member(#vs, #k, #r) }
function SLL_member(x, k){
  found := false;
  if (x = null){
    skip
  } else {
    v := [x];
    if (v = k){
      found := true
    } else {
      t := [x + 1];
      found := SLL_member(t, k)
    }
  };
  return found
}
{ SLL_ex(#x, #ps, #vs) * list_member(#vs, #k, #r) * (ret == #r) }

//
// ITERATIVE LIST MANIPULATION
//

// Freeing a given SLL
{ (x == #x) * SLL_ex(#x, #ps, #vs) }
function SLL_free_iter(x) {
  [[ invariant {bind: x, #rps, #rvs} SLL_ex(x, #rps, #rvs) ]];
  while (not (x = null)) {
    t := [x + 1];
    free(x);
    x := t
  };
  return null
}
{ (ret == null) }

// Concatenating two lists
{(x == #x) * (y == #y) * SLL_ex(#x, #px, #vx) * SLL_ex(#y, #py, #vy) }
function SLL_concat_iter(x, y){
  if (x = null) {
    head := y
  } else {
    head := x;
    prev := head;
    next := [x + 1];
    [[ invariant {bind: prev, next, #ps1, #ps2, #vs1, #vs2, #v}
          SLLseg_ex(head, prev, #ps1, #vs1) * (prev -b> #v, next) * SLL_ex(next, #ps2, #vs2) *
          (#px == #ps1 @ (prev :: #ps2)) * (#vx == #vs1 @ (#v :: #vs2)) ]];
    while (not (next = null)) {
        [[ assert {bind: #prev} prev == #prev ]];
        prev := next;
        next := [next + 1];
        [[ apply SSLseg_append(head, #prev, #ps1, #vs1, #v, prev) ]]
    };
    [prev + 1] := y;
    [[ assert {bind: #sps, #svs, #sv} SLLseg_ex(head, prev, #sps, #svs) * (prev -b> #sv, y) ]];
    [[ apply SSLseg_append(head, prev, #sps, #svs, #sv, y) ]];
    [[ apply SLLseg_concat_SLL(head, y) ]]
  };
  return head
}
{ SLL_ex(ret, #px @ #py, #vx @ #vy) }


