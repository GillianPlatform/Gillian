predicate SLL_ex(+x, ps, vs) {
  // Empty SLL
  (x == null) * (ps == []) * (vs == []);
  // One SLL node and the rest
  (x -b> #v, #next) * SLL_ex(#next, #ps, #vs) *
  (ps == x :: #ps) * (vs == #v :: #vs)
}

// mutation error 1
{ v == #v }
function SLL_allocate_node_err(v){
  t := new(2);
  [true] := v;
  return t
}
{ error: (v == #v)  * (t -b> null, null)}

// new error val
{ v == #v }
function SLL_allocate_node_err(v){
  t := new(true);
  [true] := v;
  return t
}
{ error: (v == #v) }

// look up free error
{ (x == #x) * freed(#x) }
function SLL_head_err(x){
    y := [x];
    return y
}
{ error: (x == #x) * freed(#x) }

// double-free error
{ (x == #x) * SLL_ex(#x, #xs, #vs) * (#x != null)}
function SLL_free_err(x){
    while(x != null){
        z := [x + 1];
        free(x);
        free(x);
        x := z;
    }
{ error: freed(#x) * SLL_ex(#z, #xss, #vss) * (z == #next)}

// null dereferencing error
{ (x = #x) * SLL_ex(#y, #ys, #vys)  * (#x == null)}
function list_concat(x, y){
    head := x
    while (x != null){
        x := [x + 1]
    }
    [x] := y
    return head
}
{ error: (x == #x) * SLL_ex(#y, #ys, #vys)  * (#x == null) * (head == #x)}

// self raise error
{ (x = #x) * SLL_ex(#x, #xs, #vs) * (#x == null)}
function list_copy_err(x){
  if (x = null) {
      error
  } else {
      skip
  };
  return x
}
{ error: (x = #x) * SLL_ex(#x, #xs, #vs) * (#x == null)}
