predicate SLL_ex(+x, ps, vs) {
  // Empty SLL
  (x == null) * (ps == []) * (vs == []);
  // One SLL node and the rest
  (x -b> #v, #next) * SLL_ex(#next, #ps, #vs) *
  (ps == x :: #ps) * (vs == #v :: #vs)
}

// Notes:
// 1. We don't have a way of saying which error specifically happens in specifications
// 2. There is no spatial disjunction, one can use abstractions or multiple post-conditions

// Errors, version 1: just one branch in post-condition
// This doesn't work because over-approximation is about both branches, post-condition explains only one
{ (x == #x) * SLL_ex(#x, #xs, #vs) }
function SLL_free_first_err_1(x) {
    z := [x + 1];
    free(x);
    free(x);
    return z
}
{ (#x == null) * SLL_ex(#x, #xs, #vs) }
error

// Errors, version 2: just one branch in post-condition
// This doesn't work because over-approximation is about both branches, post-condition explains only one
{ (x == #x) * SLL_ex(#x, #xs, #vs) }
function SLL_free_first_err_2(x) {
    z := [x + 1];
    free(x);
    free(x);
    return z
}
{ (! (#x == null)) * freed(#x) * (z == #z) * SLL_ex(#z, #xxs, #vvs) }
error

// Errors: version 3: both branches
// This works because it captures both branches (using multi-posts instead of spati)
{ (x == #x) * SLL_ex(#x, #xs, #vs) }
function SLL_free_first_err_3(x) {
    z := [x + 1];
    free(x);
    free(x);
    return z
}
{
    (#x == null) * SLL_ex(#x, #xs, #vs);
    (! (#x == null)) * freed(#x) * (z == #z) * SLL_ex(#z, #xxs, #vvs)
}
error

// Errors: version 4: Isolated null-pointer dereference
// This isolates a single branch in the pre-condition, it works
{ (x == #x) * SLL_ex(#x, #xs, #vs) * (#x == null) }
function SLL_free_first_err_4(x) {
    z := [x + 1];
    free(x);
    free(x);
    return z
}
{ (#x == null) * SLL_ex(#x, #xs, #vs) }
error

// Errors: version 5: Isolated double-free
// This isolates a single branch in the pre-condition, it also works
{ (x == #x) * SLL_ex(#x, #xs, #vs) * (! (#x == null)) }
function SLL_free_first_err_5(x) {
    z := [x + 1];
    free(x);
    free(x);
    return z
}
{ (! (#x == null)) * freed(#x) * (z == #z) * SLL_ex(#z, #xxs, #vvs) }
error