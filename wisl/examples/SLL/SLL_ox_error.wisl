predicate SLL_ex(+x, ps, vs) {
  // Empty SLL
  (x == null) * (ps == []) * (vs == []);
  // One SLL node and the rest
  (x -b> #v, #next) * SLL_ex(#next, #ps, #vs) *
  (ps == x :: #ps) * (vs == #v :: #vs)
}

// Notes:
// 1. Gillian can forget resource in post-conditions of functions
// 2. We don't have a way of saying which error specifically happens in specifications

// Errors, version 1: just one branch in post-condition
// This doesn't work because over-approximation is about both branches, post-condition explains only one
{ (x == #x) * SLL_ex(#x, #xs, #vs) }
function SLL_free_first_err_1(x) {
    z := [x + 1];
    free(x);
    free(x);
    return z
}
{ (#x == null) }
error

// Errors, version 2: just one branch in post-condition
// This doesn't work because over-approximation is about both branches, post-condition explains only one
{ (x == #x) * SLL_ex(#x, #xs, #vs) }
function SLL_free_first_err_2(x) {
    z := [x + 1];
    free(x);
    free(x);
    return z
}
{ (! (#x == null)) }
error

// Errors: version 3a: both branches
// This works because it captures both branches and forgets everything
{ (x == #x) * SLL_ex(#x, #xs, #vs) }
function SLL_free_first_err_3a(x) {
    z := [x + 1];
    free(x);
    free(x);
    return z
}
{ True }
error

// Errors: version 3b: both branches
// This works because it captures both branches, but this time we give the full specification
{ (x == #x) * SLL_ex(#x, #xs, #vs) }
function SLL_free_first_err_3b(x) {
    z := [x + 1];
    free(x);
    free(x);
    return z
}
{ x == null * SLL_ex(#x, #xs, #vs) }
{ freed(#x) * (z == #z) * SLL_ex(#z, #xxs, #vvs) }
error

// Errors: version 4: Isolated null-pointer dereference
// This isolates a single branch, it works
{ (x == #x) * SLL_ex(#x, #xs, #vs) * (#x == null) }
function SLL_free_first_err_4(x) {
    z := [x + 1];
    free(x);
    free(x);
    return z
}
{ (#x == null) * SLL_ex(#x, #xs, #vs) }
error

// Errors: version 5: Isolated double-free
// This isolates a single branch, it also works, and we give the full resource
{ (x == #x) * SLL_ex(#y, #xs, #vs) * (! (#x == null)) }
function SLL_free_first_err_5(x) {
    z := [x + 1];
    free(x);
    free(x);
    return z
}
{ freed(#x) * (z == #z) * SLL_ex(#z, #xxs, #vvs) }
error