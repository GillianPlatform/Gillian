predicate lambda_term(+x, v, t1, t2, type: Int, +p: Float) {
    (x -> (p: 0), (p: v), (p: t1)) * (type == 0) * (t2 == null) * lambda_term(t1, #v1, #t11, #t12, #type1, p);
    (x -> (p: 1), (p: t1), (p: t2)) * (type == 1) * (v == 0) * lambda_term(t1, #v1, #t11, #t12, #type1, p) * lambda_term(t2, #v2, #t21, #t22, #type2, p);
    (x -> (p: 2), (p: v)) * (type == 2) * (t1 == null) * (t2 == null)
}

predicate is_copy(+x, +y, +p1: Float, +p2: Float, v, t1, t2, type: Int) {
    (x -> (p1: 0), (p1: v), (p1: t1)) * (y -> (p2: 0), (p2: v), (p2: #t2)) * (type == 0) * (t2 == null) * is_copy(t1, #t2, p1, p2, #v, #t11, #t12, #type);
    (x -> (p1: 1), (p1: t1), (p1: t2)) * (y -> (p2: 1), (p2: #t21), (p2: #t22)) * (type == 1) * (v == 0) * is_copy(t1, #t21, p1, p2, #v1, #t11, #t12, #type1) * is_copy(t2, #t22, p1, p2, #v2, #t_21, #t_22, #type2);
    (x -> (p1: 2), (p1: v)) * (y -> (p2: 2), (p2: v)) * (type == 2) * (t1 == null) * (t2 == null)
}

predicate substituted(+t_in, +t, +v, +p1: Float, +p2: Float, +pt: Float, +t_out) {
    (t_in -> (p1: 0), (p1: v), (p1: #t)) * (t_out -> (p2: 0), (p2: v), (p2: #t2)) * is_copy(#t, #t2, p1, p2, #tv, #tt1, #tt2, #type1) * lambda_term(t, #w, #t11, #t12, #type2, pt);
    (t_in -> (p1: 0), (p1: #v), (p1: #t)) * (! (#v == v)) * (t_out -> (p2: 0), (p2: #v), (p2: #t_out)) * substituted(#t, t, v, p1, p2, pt, #t_out);
    (t_in -> (p1: 1), (p1: #t1), (p1: #t2)) * (t_out -> (p2: 1), (p2: #t1_out), (p2: #t2_out)) * substituted(#t1, t, v, p1, p2, pt f/ 2.0, #t1_out) * substituted(#t2, t, v, p1, p2, pt f/ 2.0, #t2_out);
    (t_in -> (p1: 2), (p1: v)) * is_copy(t, t_out, pt, p2, #v, #t1, #t2, #type);
    (t_in -> (p1: 2), (p1: #v)) * (! (v == #v)) * (t_out -> (p2: 2), (p2: #v)) * lambda_term(t, #w, #t1, #t2, #type, pt)
}

lemma split_lambda_term_permission {
    statement:
        forall x, v, t1, t2, type, p, p1, p2.
            (p == p1 f+ p2) * (p1 f> 0.0) * (p2 f> 0.0) * lambda_term(x, v, t1, t2, type, p) |- lambda_term(x, v, t1, t2, type, p1) * lambda_term(x, v, t1, t2, type, p2)

    proof:
        unfold lambda_term(x, v, t1, t2, type, p);
        if (!(type == 2)) {
            if (type == 1) {
                assert {bind: #v1, #t11, #t12, #type1, #v2, #t21, #t22, #type2} lambda_term(t1, #v1, #t11, #t12, #type1, p) * lambda_term(t2, #v2, #t21, #t22, #type2, p);
                apply split_lambda_term_permission(t1, #v1, #t11, #t12, #type1, p, p1, p2);
                apply split_lambda_term_permission(t2, #v2, #t21, #t22, #type2, p, p1, p2)
            } else {
                assert {bind: #v1, #t11, #t12, #type1} lambda_term(t1, #v1, #t11, #t12, #type1, p);
                apply split_lambda_term_permission(t1, #v1, #t11, #t12, #type1, p, p1, p2)
            };
            fold lambda_term(x, v, t1, t2, type, p1);
            fold lambda_term(x, v, t1, t2, type, p2)
        }
}

[spec copy_spec: #p]
{ (x == #x) * lambda_term(#x, #v, #t1, #t2, #type, #p) }
function copy(x) {
    type := [x];
    if (type == 2) {
        r := new(2);
        v := [x + 1];
        [r + 1] := v
    } else {
        r := new(3);
        if (type == 1) {
            t1 := [x + 1];
            t2 := [x + 2];
            par {
                r1 := copy(t1) [copy_spec: (#p: #p)];
                r2 := copy(t2) [copy_spec: (#p: #p)]
            };
            [r + 1] := r1;
            [r + 2] := r2
        } else {
            v := [x + 1];
            t1 := [x + 2];
            [r + 1] := v;
            r1 := copy(t1) [copy_spec: (#p: #p)];
            [r + 2] := r1
        }
    };
    [r] := type;
    return r
}
{ is_copy(#x, ret, #p, 1.0, #v, #t1, #t2, #type) }

[spec subst_spec: #px, #py]
{ (x == #x) * (y == #y) * (v == #v) * lambda_term(#x, #vx, #tx1, #tx2, #type_x, #px) * lambda_term(#y, #vy, #ty1, #ty2, #type_y, #py) }
function subst(x, y, v) {
    type := [x];
    if (type == 2) {
        w := [x + 1];
        if (v == w) {
            r := copy(y)[copy_spec: (#p: #py)]
        } else {
            r := copy(x)[copy_spec: (#p: #px)];
            [[unfold is_copy(#x, r, #px, 1.0, #vx, #tx1, #tx2, #type_x)]]
        }
    } else {
        r := new(3);
        [r] := type;
        if (type == 1) {
            t1 := [x + 1];
            t2 := [x + 2];
            [[assert {bind: #py_half} (#py_half == #py f/ 2.0)]];
            [[apply split_lambda_term_permission(#y, #vy, #ty1, #ty2, #type_y, #py, #py_half, #py_half)]];
            par {
                ct1 := subst(t1, y, v)[subst_spec: (#px: #px), (#py: #py_half)];
                ct2 := subst(t2, y, v)[subst_spec: (#px: #px), (#py: #py_half)]
            };
            [r + 1] := ct1;
            [r + 2] := ct2
        } else {
            w := [x + 1];
            t := [x + 2];
            if (v == w) {
                ct := copy(t)[copy_spec: (#p: #px)]
            } else {
                ct := subst(t, y, v)[subst_spec: (#px: #px), (#py: #py)]
            };
            [r + 1] := w;
            [r + 2] := ct
        }
    };
    return r
}
{ substituted(#x, #y, #v, #px, 1.0, #py, ret) }
