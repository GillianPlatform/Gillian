(* The length of an element is not smaller than the length of its first field *)
lemma CElementFirstFieldLength(buffer, readPos, fCount, field, restFields, eLength)
[[
    CElement(#buffer, #readPos, #fCount, l+({{ #field }}, #restFields), #eLength)
]]
[[
    CElement(#buffer, #readPos, #fCount, l+({{ #field }}, #restFields), #eLength) *
    (2 + l-len #field <=# #eLength)
]]
[*
    unfold CElement(#buffer, #readPos, #fCount, l+({{ #field }}, #restFields), #eLength)
*]

(* The length of a non-empty complete element is strictly positive *)
lemma CElementNonEmptyPositiveLength(buffer, readPos, fCount, fList, eLength)
[[
    CElement(#buffer, #readPos, #fCount, #fList, #eLength) * (0 <# #fCount)
]]
[[
    CElement(#buffer, #readPos, #fCount, #fList, #eLength) *
    (0 <# #eLength)
]]
[*
    unfold CElement(#buffer, #readPos, #fCount, #fList, #eLength);
    sep_assert (Field(#buffer, #readPos, #field, #fLength)) [bind: #fLength];
    sep_assert (CElement(#buffer, #readPos + #fLength, #fCount - 1, #restFields, #restELength)) [bind: #restELength]
*]

(* Appending the first field of a given complete element to a complete element on its left *)
lemma AppendFieldCC(buffer, readPos, fCount1, fList1, eLength1, fCount2, field, fList2, eLength2)
[[
    CElement(#buffer, #readPos, #fCount1, #fList1, #eLength1) *
    CElement(#buffer, #readPos + #eLength1, #fCount2, l+({{ #field }}, #fList2), #eLength2) *
    (#shift == 2 + l-len #field)
]]
[[
    CElement(#buffer, #readPos, #fCount1 + 1, l+ (#fList1, {{ #field }}), #eLength1 + #shift) *
    CElement(#buffer, #readPos + #eLength1 + #shift, #fCount2 - 1, #fList2, #eLength2 - #shift)
]]
[*
    apply CElementFirstFieldLength(#buffer, #readPos + #eLength1, #fCount2, #field, #fList2, #eLength2);
    unfold CElement(#buffer, #readPos, #fCount1, #fList1, #eLength1);
    if (0 < #fCount1) then {
        sep_assert (#fList1 == l+ ({{ #fl1 }}, #rfl1)) [bind: #fl1, #rfl1];
        sep_assert (CElement(#buffer, 2 + (l-len #fl1) + #readPos, #fCount1 - 1, #rfl1, #reL1)) [bind: #reL1];
        apply AppendFieldCC(#buffer, 2 + (l-len #fl1) + #readPos, #fCount1 - 1, #rfl1, #reL1, #fCount2, #field, #fList2, #eLength2)
    }
*]



(* Appending a complete element to the given complete elements from the right *)
lemma CElementsAppend(buffer, readPos, eCount, fCount, eList, esLength, fList, eLength)
[[
    CElements(#buffer, #readPos, #eCount, #fCount, #eList, #esLength) *
    CElement(#buffer, #readPos + #esLength, #fCount, #fList, #eLength)
]]
[[
    CElements(#buffer, #readPos, #eCount + 1, #fCount, l+ (#eList, {{ #fList }}), #esLength + #eLength)
]]
[*
    apply CElementNonEmptyPositiveLength(#buffer, #readPos + #esLength, #fCount, #fList, #eLength);
    unfold CElements(#buffer, #readPos, #eCount, #fCount, #eList, #esLength);
    if (0 < #eCount) then {
        sep_assert (CElement(#buffer, #readPos, #fCount, #newElementFieldList, #newElementLength)) [bind: #newElementFieldList, #newElementLength];
        sep_assert (CElements(#buffer, (#readPos + #newElementLength), (#eCount - 1), #fCount, #remainingElementsList, #remainingElementsLength)) [bind: #remainingElementsList, #remainingElementsLength];
        apply CElementsAppend(#buffer, (#readPos + #newElementLength), (#eCount - 1), #fCount, #remainingElementsList, #remainingElementsLength, #fList, #eLength)
    }
 *]

(* Appending the first field of a given incomplete element to a complete element on its left *)
lemma AppendFieldCI(buffer, readPos, fCount1, fList1, eLength1, fCount2, field, fList2, eLength2)
[[
    CElement(#buffer, #readPos, #fCount1, #fList1, #eLength1) *
    IElement(#buffer, #readPos + #eLength1, #fCount2, l+({{ #field }}, #fList2), #eLength2) *
    (#shift == 2 + l-len #field)
]]
[[
    CElement(#buffer, #readPos, #fCount1 + 1, l+ (#fList1, {{ #field }}), #eLength1 + #shift) *
    IElement(#buffer, #readPos + #eLength1 + #shift, #fCount2 - 1, #fList2, #eLength2 - #shift)
]]
[*
    unfold CElement(#buffer, #readPos, #fCount1, #fList1, #eLength1);
    if (0 < #fCount1) then {
        sep_assert (#fList1 == l+ ({{ #fl1 }}, #rfl1)) [bind: #fl1, #rfl1];
        sep_assert (CElement(#buffer, 2 + (l-len #fl1) + #readPos, #fCount1 - 1, #rfl1, #reL1)) [bind: #reL1];
        apply AppendFieldCI(#buffer, 2 + (l-len #fl1) + #readPos, #fCount1 - 1, #rfl1, #reL1, #fCount2, #field, #fList2, #eLength2)
    }
*]

(* Prepend an entire complete element to an incomplete element following it *)
lemma PrependCElementI(buffer, readPos, fCount1, fList1, eLength1, fCount2, fList2, eLength2)
[[
    CElement(#buffer, #readPos, #fCount1, #fList1, #eLength1) *
    IElement(#buffer, #readPos + #eLength1, #fCount2, #fList2, #eLength2)
]]
[[
    IElement(#buffer, #readPos, #fCount1 + #fCount2, l+ (#fList1, #fList2), #eLength1 + #eLength2)
]]
[*
    unfold CElement(#buffer, #readPos, #fCount1, #fList1, #eLength1);
    if (0 < #fCount1) then {
        sep_assert (#fList1 == l+ ({{ #fl1 }}, #rfl1)) [bind: #fl1, #rfl1];
        sep_assert (CElement(#buffer, 2 + (l-len #fl1) + #readPos, #fCount1 - 1, #rfl1, #reL1)) [bind: #reL1];
        apply PrependCElementI(#buffer, 2 + (l-len #fl1) + #readPos, #fCount1 - 1, #rfl1, #reL1, #fCount2, #fList2, #eLength2)
    }
*]

(* An entire complete element sequence can be prepended to a general element sequence *)
lemma PrependCElementsE(definition, buffer, readPos, eCount1, fCount, fList1, esLength1, eCount2, fList2, esLength2)
[[
    CElements(#buffer, #readPos, #eCount1, #fCount, #fList1, #esLength1) *
    Elements(#definition, #buffer, #readPos + #esLength1, #eCount2, #fCount, #fList2, #esLength2)
]]
[[
    Elements(#definition, #buffer, #readPos, #eCount1 + #eCount2, #fCount, l+ (#fList1, #fList2), #esLength1 + #esLength2)
]]
[*
    unfold CElements(#buffer, #readPos, #eCount1, #fCount, #fList1, #esLength1)
      [bind: (#element := #fList) and (#eLength := #eLength) and (#restElements := #restElements) and (#restLength := #restESLength)] ;
    if (0 < #eCount1) then {
        apply PrependCElementsE(#definition, #buffer, #readPos + #eLength, #eCount1 - 1, #fCount, #restElements, #restESLength, #eCount2, #fList2, #esLength2);
        unfold Elements(#definition, #buffer, (#eLength + #readPos), ((-1. + #eCount1) + #eCount2), #fCount, l+ (#restElements, #fList2), (#restESLength + #esLength2));
        if (definition = "Incomplete") then {
            fold IElements(#buffer, #readPos, #eCount1 + #eCount2, #fCount, l+ (#fList1, #fList2), #esLength1 + #esLength2)
        }
    }
*]

(* Every element of an element sequence has the same number of fields *)
lemma CElementsElementLength(buffer, readPos, eCount, fCount, eList, prefix, element, suffix)
[[
    CElements(#buffer, #readPos, #eCount, #fCount, #eList, #esLength) *
    (#eList == l+ (#prefix, {{ #element }}, #suffix))
]]
[[
    CElements(#buffer, #readPos, #eCount, #fCount, #eList, #esLength) *
    (l-len #element == #fCount)
]]
[*
    apply DestructList(#prefix);
    unfold CElements(#buffer, #readPos, #eCount, #fCount, #eList, #esLength);
    if (not (#prefix = {{ }})) then {
        sep_assert (CElement(#buffer, #readPos, #fCount, #fList, #elementLength)) [bind: #elementLength];
        sep_assert (#prefix == #head :: #rest) [bind: #head, #rest];
        sep_assert (CElements(#buffer, (#readPos + #elementLength), (#eCount - 1), #fCount, l+ (#rest, {{#element}}, #suffix), #restESLength)) [bind: #restESLength];
        apply CElementsElementLength(#buffer, (#readPos + #elementLength), (#eCount - 1), #fCount, l+ (#rest, {{#element}}, #suffix), #rest, #element, #suffix)
    }
 *]

(******************************
 ******************************
 *******                *******
 *******   Encryption   *******
 *******   Context      *******
 *******                *******
 ******************************
 ******************************)

(*
    The encryption context (EC) are serialised
    as a sequence of two-field elements, and is meant
    to be the only contents of the provided buffer

  buffer     EC
     |----------------|
*)

(* Broken serialised encryption context *)
nounfold pred BRawEncryptionContext(errorMessage:Str, +buffer:List, ECKs:List) :
    (* Not enough data provided *)
    (2 <# l-len buffer) *
    (#rawKC == l-sub (buffer, 0, 2)) *
    rawToUInt16(#rawKC, false, #keyCount) *
    (0 <# #keyCount) * (ECKs == {{ }}) *
    Elements("Incomplete", buffer, 2, #keyCount, 2, #eList, #esLength) *
    (errorMessage == "decodeEncryptionContext: Underflow, not enough data."),

    (* Too much data provided *)
    (2 <# l-len buffer) *
    (#rawKC == l-sub (buffer, 0, 2)) *
    rawToUInt16(#rawKC, false, #keyCount) *
    (0 <# #keyCount) *
    Elements("Complete", buffer, 2, #keyCount, 2, ECKs, #ECKsLength) *
    (! (#ECKsLength + 2 == l-len buffer)) *
    (errorMessage == "decodeEncryptionContext: Overflow, too much data."),

    (* Duplicated key in context *)
    (2 <# l-len buffer) *
    (#rawKC == l-sub (buffer, 0, 2)) *
    rawToUInt16(#rawKC, false, #keyCount) *
    (0 <# #keyCount) *
    Elements("Complete", buffer, 2, #keyCount, 2, ECKs, #ECKsLength) *
    toUtf8PairMap(ECKs, #utf8ECKs) * FirstProj(ECKs, #ECKeys) * Duplicated({{ }}, #ECKeys) *
    (2 + #ECKsLength == l-len buffer) *
    (errorMessage == "decodeEncryptionContext: Duplicate encryption context key value.");

(* General serialised encryption context *)
pred RawEncryptionContext(definition:Str, +buffer:List, ECKs:List, errorMessage:Str) :
  (definition == "Complete") * CRawEncryptionContext(buffer, ECKs) * (errorMessage == ""),
  (definition == "Broken")   * BRawEncryptionContext(errorMessage, buffer, ECKs);

(* Live decoded encryption context *)
pred LiveDecodedEncryptionContext(+dECObj : Obj, +ECKs : List) :
    JSObjWithProto(dECObj, null) *
    toUtf8PairMap(ECKs, #utf8ECKs) *
    ObjectTable(dECObj, #utf8ECKs);

(* Decoded encryption context *)
pred DecodedEncryptionContext(+dECObj : Obj, +ECKs : List) :
    JSObjGeneral(dECObj, null, "Object", false) *
    toUtf8PairMap(ECKs, #utf8ECKs) *
    FrozenObjectTable(dECObj, #utf8ECKs);


(*****************************
 *****************************
 *******               *******
 *******   Encrypted   *******
 *******   Data Keys   *******
 *******               *******
 *****************************
 *****************************)


(***** EDK objects *****)

(* Prototype of EDK objects *)
pred EDKPrototype () :
    JSObjGeneral($l_edk_proto, null, "Object", false) *
    empty_fields($l_edk_proto : -{ }-);

(* EDK objects *)
nounfold pred EncryptedDataKey(+EDK, pId:Str, pInfo:Str, encryptedDataKey:List, rawInfo:List) :
    JSObjGeneral(EDK, $l_edk_proto, "Object", false) *
    readOnlyProperty(EDK, "providerId", pId) *
    readOnlyProperty(EDK, "providerInfo", pInfo) *
    readOnlyProperty(EDK, "encryptedDataKey", #aEDK) *
        Uint8Array(#aEDK, #abEDK, 0, #viewSizeEDK) *
        ArrayBuffer(#abEDK, encryptedDataKey) *
        (#viewSizeEDK == l-len encryptedDataKey) *
    readOnlyProperty(EDK, "rawInfo", #aRInfo) *
        Uint8Array(#aRInfo, #abRInfo, 0, #viewSizeRInfo) *
        ArrayBuffer(#abRInfo, rawInfo) *
        (#viewSizeRInfo == l-len rawInfo);

(***** Arrays of deserialised EDKs *****)

(* Live array of deserialised EDKs *)
pred ArrayOfDEDKsContents(+a:Obj, contents:List, +start:Num) :
    (contents == {{ }}) * (contentsLength == 0),

    (#index == num_to_string start) *
    DataProp(a, #index, #edk) *
    EncryptedDataKey(#edk, #pId, #pInfo, #encryptedDataKey, #rawInfo) *
    fromUtf8(#rawId, #pId) * fromUtf8(#pInfo, #rawInfo) *
    (#element == {{ #rawId, #rawInfo, #encryptedDataKey }}) *
    (contents == #element :: #rest) *
    (#rest_start == start + 1) *
    ArrayOfDEDKsContents(a, #rest, #rest_start);

(* Frozen array of deserialised EDKs *)
pred FrozenArrayOfDEDKsContents(+a:Obj, contents:List, +start:Num) :
    (contents == {{ }}) * (contentsLength == 0),

    (#index == num_to_string start) *
    readOnlyProperty(a, #index, #edk) *
    EncryptedDataKey(#edk, #pId, #pInfo, #encryptedDataKey, #rawInfo) *
    fromUtf8(#rawId, #pId) * fromUtf8(#pInfo, #rawInfo) *
    (#edk == {{ #rawId, #rawInfo, #encryptedDataKey }}) *
    (contents == #edk :: #rest_contents) *
    (#rest_start == start + 1) *
    FrozenArrayOfDEDKsContents(a, #rest_contents, #rest_start);

(***** Deserialised EDKs *****)

(* EDKs are first deserialised into a live array *)
pred LiveDeserialisedEncryptedDataKeys (+a:Obj, EDKs:List) :
    ArrayStructure(a, l-len EDKs) *
    ArrayOfDEDKsContents(a, EDKs, 0);

(* Deserialised EDKs are ultimately provided as a frozen array *)
pred DeserialisedEncryptedDataKeys (+a:Obj, contents:List) :
    FrozenArrayStructure(a, l-len contents) *
    FrozenArrayOfDEDKsContents(a, contents, 0);

(************************************
 ************************************
 *******                      *******
 *******   Axiomatic          *******
 *******   UTF-8 Conversion   *******
 *******                      *******
 ************************************
 ************************************)


(* toUtf8 is injective *)
lemma toUtf8Injective(rawData1, utf8Data1, rawData2, utf8Data2)
[[
    toUtf8(#rawData1, #utf8Data1) * toUtf8(#rawData2, #utf8Data2)
]]
[[
    (#rawData1 == #rawData2) * (#utf8Data1 == #utf8Data2);
    (! (#rawData1 == #rawData2)) * (! (#utf8Data1 == #utf8Data2))
]]

(*
    fromUtf8(utf8Data, rawData) is an abstract predicate which
    denotes that the raw bytes rawData are obtained by converting
    the string utf8Data into bytes
*)
abstract pure pred fromUtf8(+utf8Data:Str, rawData:List);

(* fromUtf8 is injective *)
lemma fromUtf8Injective(utf8Data1, rawData1, utf8Data2, rawData2)
[[
    fromUtf8(#utf8Data1, #rawData1) * fromUtf8(#utf8Data2, #rawData2)
]]
[[
    (#utf8Data1 == #utf8Data2) * (#rawData1 == #rawData2);
    (! (#utf8Data1 == #utf8Data2)) * (! (#rawData1 == #rawData2))
]]

(* Invertibility of toUtf8 with respect to fromUtf8 *)
lemma toUtf8fromUtf8(rawData)
[[
    toUtf8(#rawData, #utf8Data)
]]
[[
    fromUtf8(#utf8Data, #rawData)
]]

(* Invertibility of fromUtf8 with respect to toUtf8 *)
lemma fromUtf8toUtf8(utf8Data)
[[
    fromUtf8(#utf8Data, #rawData)
]]
[[
    toUtf8(#rawData, #utf8Data)
]]

(* UTF-8 Mapping of lists *)
pure pred toUtf8Map(+data : List, utf8Data : List) :
    (data == {{ }}) * (utf8Data == {{ }}),

    (data == #fst :: #rest) *
    (toUtf8(#fst, #utf8Fst)) *
    toUtf8Map(#rest, #utf8Rest) *
    (utf8Data == #utf8Fst :: #utf8Rest);

(* toUtf8PairMap is injective *)
lemma toUtf8MapInjective(rawData1, utf8Data1, rawData2, utf8Data2)
[[
    toUtf8Map(#rawData1, #utf8Data1) * toUtf8Map(#rawData2, #utf8Data2)
]]
[[
    (#rawData1 == #rawData2) * (#utf8Data1 == #utf8Data2);
    (! (#rawData1 == #rawData2)) * (! (#utf8Data1 == #utf8Data2))
]]
[*
    unfold toUtf8Map(#rawData1, #utf8Data1);
    unfold toUtf8Map(#rawData2, #utf8Data2);
    if ((not (#rawData1 = {{ }})) and (not (#rawData2 = {{ }}))) then {
        sep_assert ((#rawData1 == #rd1 :: #restd1) * (#rawData2 == #rd2 :: #restd2) *
                    (#utf8Data1 == #ut1 :: #restu1) * (#utf8Data2 == #ut2 :: #restu2))
                    [bind: #rd1, #restd1, #rd2, #restd2, #ut1, #restu1, #ut2, #restu2];
        apply toUtf8Injective(#rd1, #ut1, #rd2, #ut2);
        apply toUtf8MapInjective(#restd1, #restu1, #restd2, #restu2)
    }
 *]

(* toUtf8PairMap is injective *)
lemma toUtf8PairMapInjective(rawData1, utf8Data1, rawData2, utf8Data2)
[[
    toUtf8PairMap(#rawData1, #utf8Data1) * toUtf8PairMap(#rawData2, #utf8Data2)
]]
[[
    (#rawData1 == #rawData2) * (#utf8Data1 == #utf8Data2);
    (! (#rawData1 == #rawData2)) * (! (#utf8Data1 == #utf8Data2))
]]
[*
    unfold toUtf8PairMap(#rawData1, #utf8Data1);
    unfold toUtf8PairMap(#rawData2, #utf8Data2);
    if ((not (#rawData1 = {{ }})) and (not (#rawData2 = {{ }}))) then {
        sep_assert ((#rawData1 == {{ #p1, #v1 }} :: #restd1) * (#rawData2 == {{ #p2, #v2 }} :: #restd2) *
                    (#utf8Data1 == {{ #up1, #uv1 }} :: #restu1) * (#utf8Data2 == {{ #up2, #uv2 }} :: #restu2))
                    [bind: #p1, #v1, #restd1, #p2, #v2, #restd2, #up1, #uv1, #restu1, #up2, #uv2, #restu2];
        apply toUtf8Injective(#p1, #up1, #p2, #up2);
        apply toUtf8Injective(#v1, #uv1, #v2, #uv2);
        apply toUtf8PairMapInjective(#restd1, #restu1, #restd2, #restu2)
    }
 *]

(* Appending a pair to a mapping of lists of pairs *)
lemma toUtf8PairMapAppendPair(data, utf8Data, prop, value)
[[
    toUtf8PairMap(#data, #utf8Data) *
    toUtf8(#prop, #utf8Prop) *
    toUtf8(#value, #utf8Value)
]]
[[
    toUtf8PairMap(l+ (#data, {{ {{ #prop, #value }} }}), l+ (#utf8Data, {{ {{ #utf8Prop, #utf8Value }} }}))
]]
[*
    unfold toUtf8PairMap(#data, #utf8Data);
    if (not (#data = {{ }})) then {
        sep_assert (#data == l+ ({{{{ #fProp, #fValue }}}}, #restPVPairs)) [bind: #fProp, #fValue, #restPVPairs];
        sep_assert (toUtf8PairMap(#restPVPairs, #restUtf8Data)) [bind: #restUtf8Data];
        apply toUtf8PairMapAppendPair(#restPVPairs, #restUtf8Data, #prop, #value)
    }
*]

(*****************************
 *****************************
 *******               *******
 *******   Algorithm   *******
 *******   Suites      *******
 *******               *******
 *****************************
 *****************************)

(* The object that holds information about allowed algorithm suites *)
pred AlgorithmSuiteIdentifierObject(o) :
    JSObject(o) *
    DataProp(o, "20",  "ALG_AES128_GCM_IV12_TAG16") * DataProp(o, "ALG_AES128_GCM_IV12_TAG16", 20) *
    DataProp(o, "70",  "ALG_AES192_GCM_IV12_TAG16") * DataProp(o, "ALG_AES192_GCM_IV12_TAG16", 70) *
    empty_fields(o : -{ "20", "70", "ALG_AES128_GCM_IV12_TAG16", "ALG_AES192_GCM_IV12_TAG16" }-);

(*
    The object representing a given algorithm suite.
    TODO: This object is more complex than presented here.
 *)
pred AlgorithmSuiteObject(+aso: Obj, ivLength: Num, tagLength: Num) :
    JSObject(aso) *
    readOnlyProperty(aso, "ivLength",  ivLength) *
    readOnlyProperty(aso, "tagLength", tagLength);

(***************************
 ***************************
 *******             *******
 *******   Message   *******
 *******   Header    *******
 *******             *******
 ***************************
 ***************************)

(* Broken version and type *)
pred BVersionAndType(+version:Num, +type:Num, errorMessage:Str) :
    (version == 65) * (type == 89) * (errorMessage == "Malformed Header: This blob may be base64 encoded."),
    (! (version == 1) \/ ! (type == 128)) * (! (version == 65) \/ ! (type == 89)) * (errorMessage == "Malformed Header: Unsupported version and/or type.");

 (********   Serialised   *******
  ********   Header       *******)

(* Serialised incomplete header *)
nounfold pred IHeader(+rawHeaderData, part_one, version, type, suiteId, messageId, ECLength,
                                      part_two, ECKs,
                                      part_three, EDKs, contentType, headerIvLength, frameLength, headerLength, headerIv, headerAuthTag) :
    (* Not enough data to read first part *)
    (l-len rawHeaderData <# 22) *

    (part_one == {{ }}) * (version == 0) * (type == 0) * (suiteId == 0) * (messageId == {{ }}) * (ECLength == 0) *
    (part_two == {{ }}) * (ECKs == {{ }}) *
    (part_three == {{ }}) * (EDKs == {{ }}) * (contentType == 0) * (headerIvLength == 0) *
    (frameLength == 0) * (headerLength == 0) * (headerIv == {{ }}) * (headerAuthTag == {{ }}),

    (* Not enough data to read encryption context *)
    (22 <=# l-len rawHeaderData) *
    (rawHeaderData == l+ (part_one, part_two)) *
    (l-len part_one == 22) *
    (part_one == l+ ({{ version, type }}, #rawSuiteId, messageId, #rawContextLength)) *
    (l-len #rawSuiteId == 2) *
    (l-len messageId == 16) *
    (l-len #rawContextLength == 2) *
    CVersionAndType(version, type) *
    rawToUInt16(#rawSuiteId, false, suiteId) *
    CAlgorithmSuite(suiteId, #stringId, headerIvLength, #tagLength) *
    rawToUInt16(#rawContextLength, false, ECLength) *
    (l-len rawHeaderData <# 22 + ECLength) *

    (ECKs == {{ }}) *
    (part_three == {{ }}) * (EDKs == {{ }}) * (contentType == 0) *
    (frameLength == 0) * (headerLength == 0) * (headerIv == {{ }}) * (headerAuthTag == {{ }}),

    (* Not enough data to read the encrypted data keys *)
    (22 <=# l-len rawHeaderData) *
    (rawHeaderData == l+ (part_one, part_two)) *
    (l-len part_one == 22) *
    (part_one == l+ ({{ version, type }}, #rawSuiteId, messageId, #rawContextLength)) *
    (l-len #rawSuiteId == 2) *
    (l-len messageId == 16) *
    (l-len #rawContextLength == 2) *
    CVersionAndType(version, type) *
    rawToUInt16(#rawSuiteId, false, suiteId) *
    CAlgorithmSuite(suiteId, #stringId, headerIvLength, #tagLength) *
    rawToUInt16(#rawContextLength, false, ECLength) *
    (22 + ECLength <=# l-len rawHeaderData) *

    (part_two == l+ (#EC, part_three)) *
    (l-len #EC == ECLength) *
    CRawEncryptionContext(#EC, ECKs) *

    RawEncryptedDataKeys("Incomplete", rawHeaderData, 22 + ECLength, EDKs, _, errorMessage) *
    (contentType == 0) * (frameLength == 0) * (headerLength == 0) * (headerIv == {{ }}) * (headerAuthTag == {{ }}),

    (* Not enough data to read the header IV and the authentication tag *)
    (22 <=# l-len rawHeaderData) *
    (rawHeaderData == l+ (part_one, part_two)) *
    (l-len part_one == 22) *
    (part_one == l+ ({{ version, type }}, #rawSuiteId, messageId, #rawContextLength)) *
    (l-len #rawSuiteId == 2) *
    (l-len messageId == 16) *
    (l-len #rawContextLength == 2) *
    CVersionAndType(version, type) *
    rawToUInt16(#rawSuiteId, false, suiteId) *
    CAlgorithmSuite(suiteId, #stringId, headerIvLength, #tagLength) *
    rawToUInt16(#rawContextLength, false, ECLength) *
    (22 + ECLength <=# l-len rawHeaderData) *

    (part_two == l+ (#EC, part_three)) *
    (l-len #EC == ECLength) *
    CRawEncryptionContext(#EC, ECKs) *

    (part_three == l+ (#edks, {{ contentType }}, {{ 0, 0, 0, 0 }}, {{ headerIvLength }}, #rawFrameLength, #rest)) *
    RawEncryptedDataKeys("Complete", rawHeaderData, 22 + ECLength, EDKs, #EDKsLength, _) *
    (#EDKsLength == l-len #edks) *
    (l-len #rawFrameLength == 4) *
    rawToUInt32(#rawFrameLength, false, frameLength) *
    (headerLength == 22 + ECLength + #EDKsLength + 1 + 4 + 1 + 4) *
    (l-len rawHeaderData <# headerLength + headerIvLength + (#tagLength / 8)) *

    (headerIv == {{ }}) * (headerAuthTag == {{ }});

(* Broken serialised header *)
nounfold pred BHeader(+rawHeaderData, part_one, version, type, suiteId, messageId, ECLength,
                                      part_two, ECKs,
                                      part_three, EDKs, contentType, headerIvLength, frameLength, headerLength, headerIv, headerAuthTag, errorMessage) :
    (* Incorrect version and/or type *)
    (22 <=# l-len rawHeaderData) *
    (rawHeaderData == l+ ({{ version, type }}, #rest)) *
    BVersionAndType(version, type, errorMessage) *

    (part_one == {{ }}) *
    (suiteId == 0) * (messageId == {{ }}) * (ECLength == 0) *
    (part_two == {{ }}) * (ECKs == {{ }}) *
    (part_three == {{ }}) * (EDKs == {{ }}) * (contentType == 0) * (headerIvLength == 0) *
    (frameLength == 0) * (headerLength == 0) * (headerIv == {{ }}) * (headerAuthTag == {{ }}),

    (* Unsupported algorithm suite *)
    (22 <=# l-len rawHeaderData) *
    (rawHeaderData == l+ ({{ version, type }}, #rawSuiteId, #rest)) *
    (l-len #rawSuiteId == 2) *
    CVersionAndType(version, type) *
    rawToUInt16(#rawSuiteId, false, suiteId) *
    BAlgorithmSuite(suiteId, errorMessage) *

    (part_one == {{ }}) * (messageId == {{ }}) * (ECLength == 0) *
    (part_two == {{ }}) * (ECKs == {{ }}) *
    (part_three == {{ }}) * (EDKs == {{ }}) * (contentType == 0) * (headerIvLength == 0) *
    (frameLength == 0) * (headerLength == 0) * (headerIv == {{ }}) * (headerAuthTag == {{ }}),

    (* Broken encryption context *)
    (22 <=# l-len rawHeaderData) *
    (rawHeaderData == l+ (part_one, part_two)) *
    (l-len part_one == 22) *
    (part_one == l+ ({{ version, type }}, #rawSuiteId, messageId, #rawContextLength)) *
    (l-len #rawSuiteId == 2) *
    (l-len messageId == 16) *
    (l-len #rawContextLength == 2) *
    CVersionAndType(version, type) *
    rawToUInt16(#rawSuiteId, false, suiteId) *
    CAlgorithmSuite(suiteId, #stringId, headerIvLength, #tagLength) *
    rawToUInt16(#rawContextLength, false, ECLength) *
    (22 + ECLength <=# l-len rawHeaderData) *

    (part_two == l+ (#EC, part_three)) *
    (l-len #EC == ECLength) *
    BRawEncryptionContext(errorMessage, #EC, ECKs) *

    (EDKs == {{ }}) * (contentType == 0) * (frameLength == 0) *
    (headerLength == 0) * (headerIv == {{ }}) * (headerAuthTag == {{ }}),

    (* Broken encrypted data keys *)
    (22 <=# l-len rawHeaderData) *
    (rawHeaderData == l+ (part_one, part_two)) *
    (l-len part_one == 22) *
    (part_one == l+ ({{ version, type }}, #rawSuiteId, messageId, #rawContextLength)) *
    (l-len #rawSuiteId == 2) *
    (l-len messageId == 16) *
    (l-len #rawContextLength == 2) *
    CVersionAndType(version, type) *
    rawToUInt16(#rawSuiteId, false, suiteId) *
    CAlgorithmSuite(suiteId, #stringId, headerIvLength, #tagLength) *
    rawToUInt16(#rawContextLength, false, ECLength) *
    (22 + ECLength <=# l-len rawHeaderData) *

    (part_two == l+ (#EC, part_three)) *
    (l-len #EC == ECLength) *
    CRawEncryptionContext(#EC, ECKs) *
    RawEncryptedDataKeys("Broken", rawHeaderData, 22 + ECLength, _, _, errorMessage) *

    (EDKs == {{ }}) * (contentType == 0) * (frameLength == 0) *
    (headerLength == 0) * (headerIv == {{ }}) * (headerAuthTag == {{ }}),

    (* Incorrect reserved bytes *)
    (22 <=# l-len rawHeaderData) *
    (rawHeaderData == l+ (part_one, part_two)) *
    (l-len part_one == 22) *
    (part_one == l+ ({{ version, type }}, #rawSuiteId, messageId, #rawContextLength)) *
    (l-len #rawSuiteId == 2) *
    (l-len messageId == 16) *
    (l-len #rawContextLength == 2) *
    CVersionAndType(version, type) *
    rawToUInt16(#rawSuiteId, false, suiteId) *
    CAlgorithmSuite(suiteId, #stringId, headerIvLength, #tagLength) *
    rawToUInt16(#rawContextLength, false, ECLength) *
    (22 + ECLength <=# l-len rawHeaderData) *

    (part_two == l+ (#EC, part_three)) *
    (l-len #EC == ECLength) *
    CRawEncryptionContext(#EC, ECKs) *
    (part_three == l+ (#edks, {{ contentType }}, #rawReservedBytes, #rest)) *
    RawEncryptedDataKeys("Complete", rawHeaderData, 22 + ECLength, EDKs, #EDKsLength, _) *
    (#EDKsLength == l-len #edks) *
    (l-len #rawReservedBytes == 4) *
    rawToUInt32(#rawReservedBytes, false, #reservedBytes) *
    (! (#reservedBytes == 0)) *
    (headerLength == 22 + ECLength + #EDKsLength + 1 + 4 + 1 + 4) *
    (headerLength + headerIvLength + (#tagLength / 8) <=# l-len rawHeaderData) *

    (errorMessage == "Malformed Header: Reserved bytes not equal to zero.") *
    (frameLength == 0) * (headerIv == {{ }}) * (headerAuthTag == {{ }}),

    (* IV length mismatch *)
    (22 <=# l-len rawHeaderData) *
    (rawHeaderData == l+ (part_one, part_two)) *
    (l-len part_one == 22) *
    (part_one == l+ ({{ version, type }}, #rawSuiteId, messageId, #rawContextLength)) *
    (l-len #rawSuiteId == 2) *
    (l-len messageId == 16) *
    (l-len #rawContextLength == 2) *
    CVersionAndType(version, type) *
    rawToUInt16(#rawSuiteId, false, suiteId) *
    CAlgorithmSuite(suiteId, #stringId, #ivLength, #tagLength) *
    rawToUInt16(#rawContextLength, false, ECLength) *
    (22 + ECLength <=# l-len rawHeaderData) *

    (part_two == l+ (#EC, part_three)) *
    (l-len #EC == ECLength) *
    CRawEncryptionContext(#EC, ECKs) *
    (part_three == l+ (#edks, {{ contentType }}, {{ 0, 0, 0, 0 }}, {{ headerIvLength }}, #rest)) *
    RawEncryptedDataKeys("Complete", rawHeaderData, 22 + ECLength, EDKs, #EDKsLength, _) *
    (#EDKsLength == l-len #edks) *
    (headerLength == 22 + ECLength + #EDKsLength + 1 + 4 + 1 + 4) *
    (headerLength + #ivLength + (#tagLength / 8) <=# l-len rawHeaderData) *
    (! (headerIvLength == #ivLength)) *

    (errorMessage == "Malformed Header: Mismatch between expected and obtained IV length.") *
    (frameLength == 0) * (headerIv == {{ }}) * (headerAuthTag == {{ }});

(* General serialised header *)
nounfold pred Header(definition, +rawHeaderData, part_one, version, type, suiteId, messageId, ECLength, part_two, ECKs, part_three, EDKs, contentType, headerIvLength, frameLength, headerLength, headerIv, headerAuthTag, errorMessage) :
    (* Complete header *)
    (definition == "Complete") *
    CHeader(rawHeaderData, part_one, version, type, suiteId, messageId, ECLength, part_two, ECKs, part_three, EDKs, contentType, headerIvLength, frameLength, headerLength, headerIv, headerAuthTag) *
    (errorMessage == ""),

    (* Incomplete header *)
    (definition == "Incomplete") *
    IHeader(rawHeaderData, part_one, version, type, suiteId, messageId, ECLength, part_two, ECKs, part_three, EDKs, contentType, headerIvLength, frameLength, headerLength, headerIv, headerAuthTag) *
    (errorMessage == ""),

    (* Broken header *)
    (definition == "Broken") *
    BHeader(rawHeaderData, part_one, version, type, suiteId, messageId, ECLength, part_two, ECKs, part_three, EDKs, contentType, headerIvLength, frameLength, headerLength, headerIv, headerAuthTag, errorMessage);

 (********   Deserialised   *******
  ********   Header         *******)

(* Deserialised main part of the message header *)
nounfold pred MessageHeader(+messageHeader, version, type, suiteId, messageId, +ECKs, EDKs, contentType, headerIvLength, frameLength) :
    JSObject(messageHeader) *
    DataProp(messageHeader, "version", version) *
    DataProp(messageHeader, "type", type) *
    DataProp(messageHeader, "suiteId", suiteId) *
    DataProp(messageHeader, "messageId", #ui8aMessageId) *
        Uint8Array(#ui8aMessageId, #abMessageId, 0, 16) *
        ArrayBuffer(#abMessageId, messageId) *
    DataProp(messageHeader, "encryptionContext", #dECObj) *
        DecodedEncryptionContext(#dECObj, ECKs) *
    DataProp(messageHeader, "encryptedDataKeys", #dEDKs) *
        DeserialisedEncryptedDataKeys(#dEDKs, EDKs) *
    DataProp(messageHeader, "contentType", contentType) *
    DataProp(messageHeader, "headerIvLength", headerIvLength) *
    DataProp(messageHeader, "frameLength", frameLength);

(* Entire deserialised header *)
nounfold pred HeaderInfo(+headerInfo, version, type, suiteId, messageId, +ECKs, EDKs, contentType, headerIvLength,
                            frameLength, headerLength, rawHeaderData, headerIv, headerAuthTag) :
    JSObject(headerInfo) *
    DataProp(headerInfo, "messageHeader", #messageHeader) *
        MessageHeader(#messageHeader, version, type, suiteId, messageId, ECKs, EDKs, contentType, headerIvLength, frameLength) *
    DataProp(headerInfo, "headerLength", headerLength) *
    DataProp(headerInfo, "algorithmSuite", #algoSuiteObject) *
        AlgorithmSuiteObject(#algoSuiteObject, headerIvLength, #tagLength) *
    DataProp(headerInfo, "rawHeader", #rawHeader) *
        Uint8Array(#rawHeader, #rawBuffer, 0, headerLength) *
        ArrayBuffer(#rawBuffer, rawHeaderData) *
    DataProp(headerInfo, "headerIv", #ui8aHeaderIv) *
        Uint8Array(#ui8aHeaderIv, #abHeaderIv, 0, headerIvLength) *
        ArrayBuffer(#abHeaderIv, headerIv) *
    DataProp(headerInfo, "headerAuthTag", #ui8aHeaderAuthTag) *
        Uint8Array(#ui8aHeaderAuthTag, #abHeaderAuthTag, 0, #tagLength / 8) *
        ArrayBuffer(#abHeaderAuthTag, headerAuthTag);

(*****************************
 *****************************
 *******               *******
 *******   Integer     *******
 *******   Reasoning   *******
 *******               *******
 *****************************
 *****************************)

(* For integers a and b, if a < b, then a + 1 <= b *)
lemma IntegerLtPlusOneLe(a, b)
[[
    (#a <# #b)
]]
[[
    (#a + 1 <=# #b)
]]

(*****************************
 *****************************
 *******               *******
 *******   List        *******
 *******   Reasoning   *******
 *******               *******
 *****************************
 *****************************)

(* Destruct on the structure of a list *)
lemma DestructList(lst)
[[
    types(#lst: List)
]]
[[
    (#lst == {{ }});
    (#lst == #hd :: #tl)
]]
(* TODO: PROOF *)

(*****************************************
 *****************************************
 *******                           *******
 *******   List first projection   *******
 *******                           *******
 *****************************************
 *****************************************)

(* FirstProj is a function *)
lemma FirstProjFunction(lst1, proj1, lst2, proj2)
[[
    FirstProj(#lst1, #proj1) * FirstProj(#lst2, #proj2) * (#lst1 == #lst2)
]]
[[
    (#proj1 == #proj2)
]]
[*
    unfold FirstProj(#lst1, #proj1) [bind: (#fst := #fst1) and (#rest := #rest1) and (#fProjRest := #fProjRest1)];
    if (not (#lst1 = {{ }})) then {
        unfold FirstProj(#lst2, #proj2) [bind: (#fst := #fst2) and (#rest := #rest2) and (#fProjRest := #fProjRest2)];
        apply FirstProjFunction(#rest1, #fProjRest1, #rest2, #fProjRest2)
    }
 *]

(* Adding a pair to a first projection *)
lemma FirstProjAppendPair(lst, fProj, prop, value)
[[
    FirstProj(#lst, #fProj)
]]
[[
    FirstProj(l+ (#lst, {{ {{ #prop, #value }} }}), l+ (#fProj, {{ #prop }}))
]]
[*
    unfold FirstProj(#lst, #fProj);
    if (not (#lst = {{ }})) then {
        sep_assert (#lst == l+ ({{{{ #fProp, #fValue }}}}, #restPVPairs)) [bind: #fProp, #fValue, #restPVPairs];
        sep_assert (FirstProj(#restPVPairs, #restProj)) [bind: #restProj];
        apply FirstProjAppendPair(#restPVPairs, #restProj, #prop, #value)
    }
*]

(* First projection goes through concatenation *)
lemma FirstProjConcatSplit(PVPairs, prefix, suffix)
[[
    (#PVPairs == l+ (#prefix, #suffix)) * FirstProj(#PVPairs, #props) *
    FirstProj(#prefix, #preProps) * FirstProj(#suffix, #sufProps)
]]
[[
    (#props == l+ (#preProps, #sufProps))
]]
[*
    apply DestructList(#prefix);
    unfold FirstProj(#prefix, #preProps);
    if (#prefix = {{ }}) then {
        apply FirstProjFunction(#PVPairs, #props, #suffix, #sufProps)
    } else {
        sep_assert (#prefix == {{ #prop, #value }} :: #restPrefix) [bind: #restPrefix];
        unfold FirstProj(#PVPairs, #props); unfold FirstProj(#prefix, #preProps);
        apply FirstProjConcatSplit(l+(#restPrefix, #suffix), #restPrefix, #suffix)
    }
*]

(* Compatibility of first projection and toUtf8 *)
lemma FirstProjToUtf8MapPairCompat(PVPairs)
[[
    FirstProj(#PVPairs, #props) *
    toUtf8PairMap(#PVPairs, #utf8PVPairs) *
    FirstProj(#utf8PVPairs, #utf8Props)
]]
[[
    toUtf8Map(#props, #utf8Props)
]]
[*
    unfold FirstProj(#PVPairs, #props);
    unfold toUtf8PairMap(#PVPairs, #utf8PVPairs);
    unfold FirstProj(#utf8PVPairs, #utf8Props);
    if (not (#PVPairs = {{ }})) then {
        sep_assert ((#PVPairs == l+ ({{ {{ _, _}} }}, #restPVPairs))) [bind: #restPVPairs];
        apply FirstProjToUtf8MapPairCompat(#restPVPairs)
    }
 *]

(******************************************
 ******************************************
 *******                            *******
 *******   List to Set conversion   *******
 *******                            *******
 ******************************************
 ******************************************)

(* ListToSet is a function *)
lemma ListToSetFunction(lst1, set1, lst2, set2)
[[
    ListToSet(#lst1, #set1) * ListToSet(#lst2, #set2) * (#lst1 == #lst2)
]]
[[
    (#set1 == #set2)
]]
[*
    unfold ListToSet(#lst1, #set1) [bind: (#e := #h1) and (#restLst := #t1) and (#restSet := #restSet1)];
    if (not (#lst1 = {{ }})) then {
        unfold ListToSet(#lst2, #set2) [bind: (#e := #h2) and (#restLst := #t2) and (#restSet := #restSet2)];
        apply ListToSetFunction(#t1, #restSet1, #t2, #restSet2)
    }
 *]

(* ListToSet concat-union compatibility *)
lemma ListToSetUnion(lst1, lst2)
[[
    ListToSet(#lst1, #set1) * ListToSet(#lst2, #set2) * ListToSet(l+ (#lst1, #lst2), #uset)
]]
[[
    (#uset == -u- (#set1, #set2))
]]
[*
    sep_assert (#x == l+ (#lst1, #lst2)) [bind: #x];
    unfold ListToSet(#lst1, #set1) [bind: (#e := #h1) and (#restLst := #rest1) and (#restSet := #restSet1)];
    if (#lst1 = {{ }}) then {
        apply ListToSetFunction(#lst2, #set2, #x, #uset)
    } else {
        unfold ListToSet(l+ (#lst1, #lst2), #uset);
        apply ListToSetUnion(#rest1, #lst2)
    }
 *]

(* Any list can be converted to a set *)
lemma ProduceListToSet(lst)
[[
    types(lst: List)
]]
[[
    ListToSet(#lst, #set)
]]
[*
    apply DestructList(#lst);
    if (not (#lst = {{ }})) then {
        sep_assert (#lst == #head :: #rest) [bind: #head, #rest];
        apply ProduceListToSet(#rest)
    }
 *]

(* Adding an element in list-to-set conversion *)
lemma ListToSetAddElement(lst, set, element)
[[
    ListToSet(#lst, #set)
]]
[[
    ListToSet(l+ (#lst, {{ #element }}), -u- (#set, -{ #element }-))
]]
[*
    unfold ListToSet(#lst, #element);
    if (not (#lst = {{ }})) then {
        sep_assert (#lst == l+ ({{ #fProp }}, #restLst)) [bind: #fProp, #restLst];
        sep_assert (ListToSet(#restLst, #restSet)) [bind: #restSet];
        apply ListToSetAddElement(#restLst, #restSet, #element)
    }
*]

(* A head of a list is always in the corresponding set *)
lemma HeadInSet(lst)
[[
    (#lst == #hd :: #tl) *
    ListToSet(#lst, #set)
]]
[[
    (#hd --e-- #set)
]]
[* *]

(* toUtf8 mapping and list membership, positive *)
lemma InListToUtf8(prop, props)
[[
    ListToSet(#props, #propsSet) *
    (#prop --e-- #propsSet) *
    toUtf8(#prop, #utf8Prop) *
    toUtf8Map(#props, #utf8Props) *
    ListToSet(#utf8Props, #utf8PropsSet)
]]
[[
    (#utf8Prop --e-- #utf8PropsSet)
]]
[*
    unfold ListToSet(#props, #propsSet);
    if (not (#props = {{ }})) then {
        sep_assert (#props == #fstProp :: #rest) [bind: #rest];
        unfold toUtf8Map(#props, #utf8Props);
        sep_assert (toUtf8(#fstProp, #utf8FstProp)) [bind: #utf8FstProp];
        sep_assert (#utf8Props == #utf8FstProp :: #restUtf8) [bind: #restUtf8];
        unfold ListToSet(#utf8Props, #utf8PropsSet);
        if (#prop = #fstProp) then {
            apply toUtf8Injective(#prop, #utf8Prop, #fstProp, #utf8FstProp)
        } else {
            apply toUtf8Injective(#prop, #utf8Prop, #fstProp, #utf8FstProp);
            apply InListToUtf8(#prop, #rest)
        }
    }
 *]

(* toUtf8 mapping and list membership, negative *)
lemma NotInListToUtf8(prop, props)
[[
    ListToSet(#props, #propsSet) *
    (! (#prop --e-- #propsSet)) *
    toUtf8(#prop, #utf8Prop) *
    toUtf8Map(#props, #utf8Props) *
    ListToSet(#utf8Props, #utf8PropsSet)
]]
[[
    (! (#utf8Prop --e-- #utf8PropsSet))
]]
[*
    unfold ListToSet(#props, #propsSet);
    unfold toUtf8Map(#props, #utf8Props);
    unfold ListToSet(#utf8Props, #utf8PropsSet);

    if (not (#props = {{ }})) then {
        sep_assert (#props == #fstProp :: #rest) [bind: #rest];
        sep_assert (toUtf8(#fstProp, #utf8FstProp)) [bind: #utf8FstProp];
        apply toUtf8Injective(#prop, #utf8Prop, #fstProp, #utf8FstProp);
        apply NotInListToUtf8(#prop, #rest)
    }
 *]

(********************************
 ********************************
 *******                  *******
 *******   Unique lists   *******
 *******                  *******
 ********************************
 ********************************)


(* In a unique list split into a left and a right sublist,
   no element from the right is on the left *)
lemma UniqueConcatSplitNotInSuffix(props, prefix, suffix, prop)
[[
    (#props == l+ (#prefix, #suffix)) * Unique(#props) *
    ListToSet(#prefix, #setPrefix) * ListToSet(#suffix, #setSuffix) *
    (#prop --e-- #setSuffix)
]]
[[
    (! (#prop --e-- #setPrefix))
]]
[*
    apply DestructList(#prefix);
    if (not (#prefix = {{ }})) then {
        sep_assert (#prefix == #firstProp :: #restPrefix) [bind: #firstProp, #restPrefix];
        unfold Unique(#props); unfold ListToSet(#prefix, #setPrefix);
        apply UniqueConcatSplitNotInSuffix(l+ (#restPrefix, #suffix), #restPrefix, #suffix, #prop);
        branch(#firstProp == #prop);
        if (#firstProp = #prop) then {
            apply ListToSetUnion(#restPrefix, #suffix)
        }
    } else {
        unfold ListToSet(#prefix, #setPrefix)
    }
*]

(* Appending an element to a unique list *)
lemma UniqueAppendElement(lst, element)
[[
    Unique(#lst) * ListToSet(#lst, #set) *
    (! (#element --e-- #set))
]]
[[
    Unique(l+ (#lst, {{ #element }}))
]]
[*
    unfold Unique(#lst) [bind: (#fst := #fst) and (#rest := #rest) and (#setRest := #setRest1)];
    if (not (#lst = {{ }})) then {
        unfold ListToSet(#lst, #set) [bind: (#restSet := #setRest2)];
        apply ListToSetFunction(#rest, #setRest1, #rest, #setRest2);
        apply UniqueAppendElement(#rest, #element);
        apply ListToSetAddElement(#rest, #setRest2, #element)
    }
 *]

(************************************
 ************************************
 *******                      *******
 *******   Duplicated lists   *******
 *******                      *******
 ************************************
 ************************************)

(* Lists with duplicates *)
pure pred Duplicated(+prefix:List, +suffix:List) :
    (* Either the head is duplicated *)
    (suffix == #fst :: #rest) *
    ListToSet(prefix, #preSet) *
    (#fst --e-- #preSet),

    (* Or the duplication is in the tail *)
    (suffix == #fst :: #rest) *
    ListToSet(prefix, #preSet) *
    (! (#fst --e-- #preSet)) *
    Duplicated(l+ (prefix, {{ #fst }}), #rest);

(*************************************
 *************************************
 *******                       *******
 *******   Objects-as-Tables   *******
 *******                       *******
 *************************************
 *************************************)

(* Object properties as a table *)
pred ObjectTableStructure(+l:Obj, +PVPairs:List) :
    (* Base case - no properties left *)
    (PVPairs == {{ }}),

    (* Recursive case - one property and the rest *)
    (PVPairs == {{ #prop, #value }} :: #restPVPairs) *
    DataProp(l, #prop, #value) * types(#value : Str) *
    ObjectTableStructure(l, #restPVPairs);

(* Complete Object-as-Table predicate *)
nounfold pred ObjectTable(+l:Obj, +PVPairs:List) :
    ObjectTableStructure(l, PVPairs) *
    FirstProj(PVPairs, #pList) *
    ListToSet(#pList, #pSet) *
    empty_fields(l : #pSet);

(* Object-as-Table absent property *)
lemma ObjectTableAbsentProperty(l, PVPairs, prop)
[[
    ObjectTableStructure(#l, #PVPairs) *
    FirstProj(#PVPairs, #pList) *
    ListToSet(#pList, #pSet) *
    empty_fields(l : #pSet) *
    (! (#prop --e-- #pSet))
]]
[[
    ObjectTableStructure(#l, #PVPairs) *
    ((#l, #prop) -> none) *
    empty_fields(#l : -u- (#pSet, -{ #prop }-))
]]
[*  *]

(* Removing a property from a list of prop-value pairs *)
pred RemoveProp(+PVPairs : List, +prop : Str, found : Bool, value : Str, newPairs : List) :
    (PVPairs == {{ }}) * (found == false) * (value == "") * (newPairs == {{ }}),

    (PVPairs == {{ prop, value }} :: newPairs) * (found == true),

    (PVPairs == {{ #fstProp, #fstValue }} :: #restPVPairs) *
    (! (#fstProp == prop)) * RemoveProp(#restPVPairs, prop, false, value, newPairs) *
    (found == false),

    (PVPairs == {{ #fstProp, #fstValue }} :: #restPVPairs) *
    (! (#fstProp == prop)) * RemoveProp(#restPVPairs, prop, true, value, #restNewPairs) *
    (found == true) * (newPairs == {{ #fstProp, #fstValue }} :: #restNewPairs);

(* Object-as-Table present property *)
lemma ObjectTablePresentProperty(l, PVPairs, prop)
[[
    ObjectTableStructure(#l, #PVPairs) *
    FirstProj(#PVPairs, #pList) *
    ListToSet(#pList, #pSet) *
    (#prop --e-- #pSet)
]]
[[
    RemoveProp(#PVPairs, #prop, true, #value, #newPairs) *
    ObjectTableStructure(#l, #newPairs) *
    DataProp(#l, #prop, #value) * types(#value : Str)
]]
[*
    unfold ObjectTableStructure(#l, #PVPairs);
    if (#PVPairs = {{ }}) then {
        unfold FirstProj(#PVPairs, #pList);
        unfold ListToSet(#pList, #pSet)
    } else {
        sep_assert (#PVPairs == l+ ({{{{ #fProp, #fValue }}}}, #restPVPairs)) [bind: #fProp, #fValue, #restPVPairs];
        sep_assert (ObjectTableStructure(#l, #restPVPairs));
        if (not (#fProp = #prop)) then {
            unfold FirstProj(#PVPairs, #pList);
            unfold ListToSet(#pList, #pSet);
            apply ObjectTablePresentProperty(#l, #restPVPairs, #prop)
        }
    }
 *]

(* Appending property to Object-as-Table structure from the right *)
lemma ObjectTableStructureAppendPVPair(l, PVPairs, prop, value)
[[
    ObjectTableStructure(#l, #PVPairs) *
    FirstProj(#PVPairs, #pList) *
    ListToSet(#pList, #pSet) *
    (! (#prop --e-- #pSet)) *
    DataProp(#l, #prop, #value) * types(#value : Str)
]]
[[
    ObjectTableStructure(#l, l+ (#PVPairs, {{ {{ #prop, #value }} }}))
]]
[*
    unfold ObjectTableStructure(#l, #PVPairs);
    if (not (#PVPairs = {{ }})) then {
        sep_assert (#PVPairs == l+ ({{{{ #fProp, #fValue }}}}, #restPVPairs)) [bind: #fProp, #fValue, #restPVPairs];
        sep_assert (ObjectTableStructure(#l, #restPVPairs));
        unfold FirstProj(#PVPairs, #pList);
        unfold ListToSet(#pList, #pSet);
        apply ObjectTableStructureAppendPVPair(#l, #restPVPairs, #prop, #value);
        sep_assert(True)
    }
 *]

(* Appending property to Object-as-Table from the right *)
lemma ObjectTableAppendPVPair(l, PVPairs, prop, value)
[[
    ObjectTableStructure(#l, #PVPairs) *
    FirstProj(#PVPairs, #pList) *
    ListToSet(#pList, #pSet) *
    (! (#prop --e-- #pSet)) *
    DataProp(#l, #prop, #value) * types(#value : Str) *
    empty_fields(l : -u- (#pSet, -{ #prop }-))
]]
[[
    ObjectTable(#l, l+ (#PVPairs, {{ {{ #prop, #value }} }}))
]]
[*
    apply FirstProjAppendPair(#PVPairs, #pList, #prop, #value);
    apply ListToSetAddElement(#pList, #pSet, #prop);
    apply ObjectTableStructureAppendPVPair(#l, #PVPairs, #prop, #value)
 *]

(* Frozen object properties *)
pred FrozenObjectTableStructure(+l:Obj, +PVPairs:List) :
    (* Base case - no properties left *)
    (PVPairs == {{ }}),

    (* Recursive case - one property and the rest *)
    (PVPairs == {{ #prop, #value }} :: #restPVPairs) *
    DataPropConst(l, #prop, #value, true) *
    FrozenObjectTableStructure(l, #restPVPairs);

(* Frozen Object-as-Table predicate *)
nounfold pred FrozenObjectTable(+l:Obj, +PVPairs:List) :
    FrozenObjectTableStructure(l, PVPairs) *
    FirstProj(PVPairs, #pList) *
    ListToSet(#pList, #pSet) *
    empty_fields(l : #pSet);

(******************************
 ******************************
 *******                *******
 *******   Additional   *******
 *******   Internal/    *******
 *******   Built-in     *******
 *******   Functions    *******
 *******                *******
 ******************************
 ******************************)

(* *** Array.prototype.map *** *)
axiomatic incomplete spec AP_map (xsc, vthis, cfun)
(* Mapping EDKs into the resulting decoded EDK array *)
[[
    (vthis == #vthis) * (cfun == #cfun) *
    JSFunctionObject(#cfun, "aux_deserializeEncryptedDataKey", #a_sc, #a_len, #a_proto) *
    ArrayOfArraysOfUInt8Arrays(#vthis, #EDKs)
]]
[[
    JSFunctionObject(#cfun, "aux_deserializeEncryptedDataKey", #a_sc, #a_len, #a_proto) *
    ArrayOfArraysOfUInt8Arrays(#vthis, #EDKs) *
    types(ret : Obj) * LiveDeserialisedEncryptedDataKeys(ret, #EDKs)
]]
normal

(* *** Object.freeze *** *)
axiomatic spec Object_freeze(xsc, vthis, l)
(* Freezing an array of deserialised EDKs *)
<deserialised_EDKS>
[[
    (l == #l) * LiveDeserialisedEncryptedDataKeys(#l, #EDKs)
]]
[[
    DeserialisedEncryptedDataKeys(#l, #EDKs) * (ret == #l)
]]
normal;

(* Freezing an Object-as-Table *)
<object_table : #PVPairs>
[[
    (l == #l) *
    JSObjGeneral(#l, #proto, #class, #ext) *
    ObjectTable(#l, #PVPairs)
]]
[[
    JSObjGeneral(#l, #proto, #class, false) *
    FrozenObjectTable(#l, #PVPairs)
]]
normal

(* *** Conversion to an integer *** *)
proc i__toInteger (v) {
			ret := "i__toNumber" (v) with elab;
			ret := num_to_int (ret);

	rlab: return;
	elab: throw
};

(* *** Conversion to a 32-bit integer *** *)
proc i__toUint32 (v) {
			ret := "i__toNumber" (v) with elab;
			ret := num_to_uint32 (ret);

	rlab: return;
	elab: throw
};

(* *** Conversion to an array length *** *)
proc i__toLength (v) {

		   ret := "i__toInteger"(v) with elab;
		   goto [ret <= 0] rlab nzero;

	nzero: goto [ret <= 9007199254740991] min rlab;
    min:   return;


	rlab: PHI(ret: 0, 9007199254740991);
          return;

	elab: throw
};

(* *** Is a string an array index *** *)
proc a__isIdx (s) {
			ret := "i__toUint32" (s) with elab;
			ret := "i__toString" (ret) with elab;

			goto [ret = s] check ret_f;

	check:	ret := not (ret = "4294967295");
			goto rlab;

	ret_f:	ret := false;

	rlab: return;
	elab: throw
};

(* *** Array defineOwnProperty *** *)
proc a__defineOwnProperty (l, prop, desc, thrw) {

			oldLenDesc := "getOwnProperty" (l, "length");
			oldLen := l-nth (oldLenDesc, 1);
			ret := "i__toUint32" (oldLen) with elab;
			oldLenNum := ret;

			goto [prop = "length"] getall is_idx;

	is_idx:	idxp := "a__isIdx" (prop);
			goto [idxp] idx norm;

	idx:	index := "i__toUint32" (prop);
			index := index;
			oldLen := oldLen;
			ret := l-nth (oldLenDesc, 2);
			goto [(not (index < oldLenNum)) and (not (l-nth (oldLenDesc, 2)))] reject idop;
	idop:	ret := "o__defineOwnProperty" (l, prop, desc, false) with elab;
			goto [ret = false] reject ilen;
	ilen:	goto [not (index < oldLenNum)] setl rlab;
	setl:	ret := "o__defineOwnProperty" (l, "length", {{ "d", (index + 1), l-nth (oldLenDesc, 2), l-nth (oldLenDesc, 3), l-nth (oldLenDesc, 4) }}, false);
			goto rlab;

	norm:	ret := "o__defineOwnProperty" (l, prop, desc, thrw) with elab;
			goto rlab;

	getall:	goto [l-nth (desc, 0) = "d"] ddd odd;

			(* Data *)
	ddd:	de := l-nth (desc, 3);
			dc := l-nth (desc, 4);
			dv := l-nth (desc, 1);
			dw := l-nth (desc, 2);
			dg := empty;
			ds := empty;
			goto sla;

	odd:	goto [l-nth (desc, 0) = "a"] add gdd;

			(* Accessor *)
	add:	de := l-nth (desc, 3);
			dc := l-nth (desc, 4);
			dv := empty;
			dw := empty;
			dg := l-nth (desc, 1);
			ds := l-nth (desc, 2);
			goto sla;

			(* Generic *)
	gdd:	de := l-nth (desc, 1);
			dc := l-nth (desc, 2);
			dv := l-nth (desc, 3);
			dw := l-nth (desc, 4);
			dg := l-nth (desc, 5);
			ds := l-nth (desc, 6);

	sla:	goto [dv = empty] slai slb;

	slai:	ret := "o__defineOwnProperty" (l, "length", desc, thrw) with elab;
			goto rlab;

	slb:	ret := "i__toUint32" (dv) with elab;
			newLen := ret;
			ret := "i__toNumber" (dv) with elab;
			goto [not (newLen = ret)] rgerr sle;

	sle:	dv := newLen;
			goto [not (newLen < oldLenNum)] slfi slg;

	slfi:	ret := "o__defineOwnProperty" (l, "length", {{ "g", de, dc, dv, dw, dg, ds }}, thrw) with elab;
			goto rlab;

	slg:	goto [l-nth (oldLenDesc, 2) = false] reject slh;

	slh:	goto [dw = false] sli slh1;

	slh1:	newWritable := true;
			goto slj;

	sli:	newWritable := false;
			dw := true;

	slj:	ret := "o__defineOwnProperty" (l, "length", {{ "g", de, dc, dv, dw, dg, ds }}, thrw) with elab;
			goto [ret = false] tf loop;

	loop:	goto [newLen < oldLen] head slm;
	head:	oldLen := oldLen - 1;
			ret := "i__toString" (oldLen) with elab;
			ret := "deleteProperty" (l, ret, false) with elab;
			goto [ret = false] fix next;

	fix:	dv := oldLen + 1;
			goto [newWritable = false] setwr defl;
	setwr:	dw := false;
	defl:	ret := "o__defineOwnProperty" (l, "length", {{ "g", de, dc, dv, dw, dg, ds }}, thrw) with elab;
			goto reject;

	next:	goto loop;

	slm:	goto [newWritable = false] slmi sln;

	slmi:	ret := "o__defineOwnProperty" (l, "length", {{ "g", empty, empty, empty, false, empty, empty }}, false) with elab;

	sln:	ret := true;
	rlab: return;

	rgerr:	ret := "RangeError" ();
			goto elab;

	reject:	goto [thrw] tt tf;

	tt:		ret := "TypeError" ();
	elab: throw;

	tf:		ret := false;
			goto rlab
};

(* *** Array constructor *** *)
proc Array_construct (xsc, vthis) {
            (* Default array construction *)
            array := "create_default_object" ($larr_proto, "Array", true);
            [array, "length"] := {{ "d", 0, true, false, true }};

            (* All runtime arguments *)
            arguments := args;
            (* Optional arguments (4) *)
            opt_args := cdr (cdr arguments);
            len := l-len (opt_args);
            goto [len = 0] rlab ltest;
  ltest:    goto [len = 1] arr_a arr_b;

            (* Form 4(a): new Array(len) *)
  arr_a:    len := l-nth (opt_args, 0);
            prop_name := "length";
            prop_num := "0";
            goto [typeOf len = Num] check set;
  check:    len_32 := "i__toUint32" (len) with elab;
            goto [len = len_32] set thrw;

  set:      PHI(prop_a: prop_num, prop_name; enum: true, false);
            ret_def_a := "a__defineOwnProperty" (array, prop_a, {{ "d", len, true, enum, true }}, true) with elab;
            goto rlab;

            (* Form 4(b): new Array([item1 [, item2 [, ...]]] *)
  arr_b:    start_n := 0;
  loop:	    PHI(n: start_n, next_n);
            goto [n < len] head rlab;
  head:     prop_b := "i__toString" (n) with elab;
            prop_val := l-nth (opt_args, n);
            ret_def_b := "a__defineOwnProperty" (array, prop_b, {{ "d", prop_val, true, true, true }}, true) with elab;
            next_n := n + 1;
            goto loop;

            (* Normal return *)
  rlab:	    ret := array;
            return;

            (* Error return *)
  thrw:     range_err := "RangeError" ();
  elab:     PHI(ret: len_32, ret_def_a, prop, ret_def_b, range_err);
            throw
};

(* *** Array.prototype.map implementation *** *)
proc AP_map(xsc, vthis, callbackfn) {
          arguments := args;
          num := l-len (arguments);

          arr_obj := "i__toObject" (vthis) with elab;
          get_len := "get" (arr_obj, "length") with elab;
          len := "i__toLength" (get_len) with elab;

          is_call := "i__isCallable" (callbackfn);
          goto [is_call] cont thrw;

          (* Check if optional thisArg is supplied at runtime *)
  cont:	  undef_t := undefined;
          goto [num > 3] def set_t;
  def:    def_t := l-nth (arguments, 3);
  set_t:  PHI(t: undef_t, def_t);

          new_arr := "Array_construct" (empty, empty, len) with elab;

          (* Loop start *)
          start := 0;
  loop:	  PHI(k: start, next_k);
          goto [k < len] next end;

  next:	  pk := "i__toString" (k) with elab;
          kpres := "hasProperty" (arr_obj, pk) with elab;
          goto [kpres] tt ff;

  tt:     kval := "get" (arr_obj, pk) with elab;
          m := metadata(callbackfn);
          scp := [m, "@scope"];
          fun := [m, "@call"];
          mapv := fun (scp, t, kval, k, arr_obj) with elab;
          ret_def := "a__defineOwnProperty" (new_arr, pk, {{ "d", mapv, true, true, true }}, false) with elab;

  ff:     next_k := k + 1;
          goto loop;
          (* Loop end *)
          (* Normal/ return *)
  end:    ret := new_arr;
          return;

          (* Error return *)
  thrw:   type_err := "TypeError" ();
  elab:   PHI(ret: arr_obj, get_len, len, new_arr, pk, kpres, kval, mapv, ret_def, type_err);
          throw
};