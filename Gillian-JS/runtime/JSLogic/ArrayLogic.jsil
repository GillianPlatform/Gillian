(* *********************************************
   ****************    Array    ****************
   ********************************************* *)

(*********************************
 **** Common Array Structure  ****
 *********************************)

pred ArrayStructure(a:Obj, arrayLength:Num) :
  ((a, "push") -> none) *                            (* Push must be found in the prototype *)
  ((a, "map")  -> none) *

  MetaData(a, #md) * MetaData(#md, null) *
  ((#md, "@proto")                 -> $larr_proto) * (* Prototype is the array prototype    *)
  ((#md, "@class")                 -> "Array") *     (* Class is "Array"                    *)
  ((#md, "@extensible")            -> true) *        (* Array buffers are extensible        *)
  empty_fields (#md : -{ "@class", "@extensible", "@proto" }-) *

  ((a, "length") -> {{ "d", arrayLength, true, false, false }});

(*******************************
 **** Array of Uint8Arrays  ****
 *******************************)

pred ArrayOfUInt8ArraysContents(+a:Obj, contents:List, +start:Num, +contentsLength:Num) :
    (contents == {{ }}) * (contentsLength == 0),

    (contentsLength == l-len contents) *
    (#index == num_to_string start) *
    (contents == #element :: #rest) *
    (#rest_start == start + 1) *
    (#rest_length == contentsLength - 1) *
    DataProp(a, #index, #ui8a) *
    Uint8Array (#ui8a, #ab, 0, #viewSize) *
    ArrayBuffer(#ab, #element) *
    (#viewSize == l-len #element) *
    ArrayOfUInt8ArraysContents(a, #rest, #rest_start, #rest_length);

pred ArrayOfUInt8Arrays (+a:Obj, contents:List, arrayLength:Num) :
    ArrayStructure(a, arrayLength) *
    ArrayOfUInt8ArraysContents(a, contents, 0, arrayLength);

(* ----------------------------------------------------------------------------------- *)

pred ArrayOfArraysOfUInt8ArraysContents(+a:Obj, contents:List, +start:Num, contentsLength:Num) :
    (contents == {{ }}) * (contentsLength == 0),

    (#index == num_to_string start) *
    (contents == #elementContents :: #rest) *
    DataProp(a, #index, #aui8a) *
    ArrayOfUInt8Arrays (#aui8a, #elementContents, _) *
    (contentsLength == l-len contents) *
    (#rest_start == start + 1) *
    (#rest_contents == contentsLength - 1) *
    ArrayOfArraysOfUInt8ArraysContents(a, #rest, #rest_start, #rest_contents);

pred ArrayOfArraysOfUInt8Arrays (+a:Obj, contents:List, arrayLength:Num) :
    ArrayStructure(a, arrayLength) *
    ArrayOfArraysOfUInt8ArraysContents(a, contents, 0, arrayLength);

(**************************
 **** Array Prototype  ****
 **************************)

nounfold pred ArrayPrototype (proto) :
  JSObjWithProto (proto, $lobj_proto) *
  empty_fields (proto : -{ "push", "map" }-) *

  ((proto, "push") -> {{ "d", $lap_push, true, false, true }}) * (* Array.prototype.push  *)
  ((proto, "map")  -> {{ "d", $lap_map,  true, false, true }}) * (* Array.prototype.map   *)

  JSBIFunction($lap_push, "AP_push", 1) * (* Actual push function *)
    empty_fields($lap_push : -{ "length" }-) *
  JSBIFunction($lap_map, "AP_map", 1) *  (* Actual map function *)
    empty_fields($lap_map : -{ "length" }-);

(*******************************************************************
 **** Axiomatic specifications of the Array prototype functions ****
 *******************************************************************)

only spec AP_push (xsc, vthis, element)
    [[ (vthis == #vthis) * (element == #ui8a) *
       Uint8Array (#ui8a, #ab, 0, #viewSize) *
       ArrayBuffer(#ab, #element) *
       (#viewSize == l-len #element) *
       ArrayOfUInt8Arrays(#vthis, #contents, #arraylength) ]]
    [[ ArrayOfUInt8Arrays(#vthis, l+ (#contents, {{ #element }}), #arraylength + 1) * (ret == undefined) ]]
    normal;

    [[ (vthis == #vthis) * (element == #aui8a) *
       ArrayOfUInt8Arrays (#aui8a, #aContents, _) *
       ArrayOfArraysOfUInt8Arrays(#vthis, #contents, #arraylength) ]]
    [[ ArrayOfArraysOfUInt8Arrays(#vthis, l+ (#contents, {{ #aContents }}), #arraylength + 1) * (ret == undefined) ]]
    normal

(*********************
 **** OTHER STUFF ****
 *********************)

pred JSInternals () :
    GlobalObject () *
    ObjectPrototype($lobj_proto) *
    ArrayPrototype ($larr_proto) *
    ArrayBufferPrototype ($lab_proto) *
    BI_DataViewObject () *
    DataViewPrototype($ldv_proto) *
    Uint8ArrayPrototype($lui8ar_proto);

pred Field(+view:List, +readPos:Num, field:List, fieldLength:Num) :
    (#rawFL == l-sub (view, readPos, 2)) *
    rawToUInt16(#rawFL, false, fieldLength) *
    (field == l-sub(view, readPos + 2, fieldLength));

pred Element(+view:List, +readPos:Num, +fieldCount: Num, fieldsList:List, elementLength:Num) :
    (0 <=# readPos) * (fieldCount == 0) * (fieldsList == {{ }}) * (elementLength == 0) *
    (readPos + elementLength <=# l-len view),

    (0 <=# readPos) * (0 <# fieldCount) * (0 <# elementLength) *
    Field(view, readPos, #field, #fieldLength) *
    (#restFieldCount == fieldCount - 1) *
    Element(view, readPos + 2 + #fieldLength, #restFieldCount, #restFields, #restElementLength) *
    (0 <=# #restElementLength) *
    (fieldsList == #field :: #restFields) *
    (elementLength == 2 + #fieldLength + #restElementLength) *
    (readPos + elementLength <=# l-len view);

lemma ElementPureFacts(view, readPos, fieldCount, fieldList, elementLength)
    [[ (view == #view) * (readPos == #readPos) * (fieldCount == #fieldCount) *
       (fieldList == #fieldList) * (elementLength == #elementLength) *
       Element (#view, #readPos, #fieldCount, #fieldList, #elementLength) ]]
    [[ Element (#view, #readPos, #fieldCount, #fieldList, #elementLength) *
       (0 <=# #readPos) *
       (0 <=# #fieldCount) *
       (0 <=# #elementLength) *
       (#readPos + #elementLength <=# l-len #view) ]] [* *]

lemma NonEmptyElementLength(view, readPos, fieldCount, field, restFieldList, elementLength)
    [[ (view == #view) * (readPos == #readPos) * (fieldCount == #fieldCount) *
       (field == #field) * (restFieldList == #restFieldList) * (elementLength == #elementLength) *
       Element (#view, #readPos, #fieldCount, l+({{ #field }}, #restFieldList), #elementLength) ]]
    [[ Element (#view, #readPos, #fieldCount, l+({{ #field }}, #restFieldList), #elementLength) *
       (2 + l-len #field <=# #elementLength) ]] [* *]

lemma ElementAppend(view, readPos, fC1, fL1, eL1, fC2, field, fL2, eL2)
    [[ (view == #view) * (readPos == #readPos) * (fC1 == #fC1) * (fL1 == #fL1) * (eL1 == #eL1) *
       (fC2 == #fC2) * (field == #field) * (fL2 == #fL2) * (eL2 == #eL2) *
       Element(#view, #readPos, #fC1, #fL1, #eL1) *
       Element(#view, #readPos + #eL1, #fC2, l+({{ #field }}, #fL2), #eL2) *
       (#shift == 2 + l-len #field) ]]
    [[ Element(#view, #readPos, #fC1 + 1, l+ (#fL1, {{ #field }}), #eL1 + #shift) *
       Element(#view, #readPos + #eL1 + #shift, #fC2 - 1, #fL2, #eL2 - #shift) ]]
[*
    sep_apply ElementPureFacts(#view, #readPos, #fC1, #fL1, #eL1);
    sep_apply ElementPureFacts(#view, #readPos + #eL1, #fC2, l+({{ #field }}, #fL2), #eL2);
    sep_apply NonEmptyElementLength(#view, #readPos + #eL1, #fC2, #field, #fL2, #eL2);
    unfold Element(#view, #readPos, #fC1, #fL1, #eL1);
    if (not (#fC1 = 0)) then {
      sep_assert (#fL1 == l+ ({{ #fl1 }}, #rfl1)) [bind: #fl1, #rfl1];
      sep_assert (Element(#view, 2 + (l-len #fl1) + #readPos, #fC1 - 1, #rfl1, #reL1)) [bind: #reL1];
      sep_apply ElementPureFacts(#view, 2 + (l-len #fl1) + #readPos, #fC1 - 1, #rfl1, #reL1);
      sep_apply ElementAppend(#view, 2 + (l-len #fl1) + #readPos, #fC1 - 1, #rfl1, #reL1, #fC2, #field, #fL2, #eL2);
      fold Element(#view, #readPos, #fC1 + 1, l+ (#fL1, {{ #field }}), #eL1 + #shift)
    }
 *]

pred Elements(+view:List, +readPos:Num, +elementCount: Num, +fieldCount: Num, elementsList:List, elementsLength:Num) :
    (0 <=# readPos) * (elementCount == 0) * (0 <# fieldCount) * (elementsList == {{ }}) * (elementsLength == 0) *
    (readPos + elementsLength <=# l-len view),

    (0 <=# readPos) * (0 <# elementCount) * (0 <# fieldCount) * (0 <# elementsLength) *
    Element(view, readPos, fieldCount, #fieldsList, #elementLength) *
    (#restElementCount == elementCount - 1) *
    Elements(view, readPos + #elementLength, #restElementCount, fieldCount, #restElements, #restElementsLength) *
    (0 <=# #restElementsLength) *
    (elementsList == #fieldsList :: #restElements) *
    (elementsLength == #elementLength + #restElementsLength) *
    (readPos + elementsLength <=# l-len view);

lemma ElementsPureFacts(view, readPos, elementCount, fieldCount, elementList, elementsLength)
    [[ (view == #view) * (readPos == #readPos) * (elementCount == #elementCount) *
       (fieldCount == #fieldCount) * (elementList == #elementList) * (elementsLength == #elementsLength) *
       Elements (#view, #readPos, #elementCount, #fieldCount, #elementList, #elementsLength) ]]
    [[ Elements (#view, #readPos, #elementCount, #fieldCount, #elementList, #elementsLength) *
       (0 <=# #readPos) *
       (0 <# #fieldCount) *
       (0 <=# #elementCount) *
       (0 <=# #elementsLength) *
       (#readPos + #elementsLength <=# l-len #view) ]] [* *]

lemma ElementsAppend(view, readPos, elementCount, fieldCount, elementList, elementsLength, fieldList, elementLength)
    [[ (view == #view) * (readPos == #readPos) * (elementCount == #elementCount) *
       (fieldCount == #fieldCount) * (elementList == #elementList) * (elementsLength == #elementsLength) *
       (fieldList == #fieldList) * (elementLength == #elementLength) *
       Elements(#view, #readPos, #elementCount, #fieldCount, #elementList, #elementsLength) *
       Element (#view, #readPos + #elementsLength, #fieldCount, #fieldList, #elementLength) ]]
    [[ Elements(#view, #readPos, #elementCount + 1, #fieldCount, l+ (#elementList, {{ #fieldList }}), #elementsLength + #elementLength) ]]
[*
    unfold Elements(#view, #readPos, #elementCount, #fieldCount, #elementList, #elementsLength);
    if (not (#elementCount = 0)) then {
      sep_assert (Element(#view, #readPos, #fieldCount, #newElementFieldList, #newElementLength)) [bind: #newElementFieldList, #newElementLength];
      sep_apply ElementPureFacts(#view, #readPos, #fieldCount, #newElementFieldList, #newElementLength);
      sep_assert (Elements(#view, (#readPos + #newElementLength), (#elementCount - 1), #fieldCount, #remainingElementsList, #remainingElementsLength)) [bind: #remainingElementsList, #remainingElementsLength];
      sep_apply ElementsAppend(#view, (#readPos + #newElementLength), (#elementCount - 1), #fieldCount, #remainingElementsList, #remainingElementsLength, #fieldList, #elementLength)
    }
 *]