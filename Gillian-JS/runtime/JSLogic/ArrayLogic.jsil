(* *********************************************
   ****************    Array    ****************
   ********************************************* *)

(*********************************
 **** Common Array Structure  ****
 *********************************)

pred ArrayStructure(a:Obj, arrayLength:Num) :
  ((a, "push") -> none) *                            (* Push must be found in the prototype *)
  ((a, "map")  -> none) *

  MetaData(a, #md) * MetaData(#md, null) *
  ((#md, "@proto")                 -> $larr_proto) * (* Prototype is the array prototype    *)
  ((#md, "@class")                 -> "Array") *     (* Class is "Array"                    *)
  ((#md, "@extensible")            -> true) *        (* Array buffers are extensible        *)
  empty_fields (#md : -{ "@class", "@extensible", "@proto" }-) *

  ((a, "length") -> {{ "d", arrayLength, true, false, false }});

(*******************************
 **** Array of Uint8Arrays  ****
 *******************************)

pred ArrayOfUInt8ArraysContents(+a:Obj, contents:List, +start:Num, +contentsLength:Num) :
    (contents == {{ }}) * (contentsLength == 0),

    (contentsLength == l-len contents) *
    (#index == num_to_string start) *
    (contents == #element :: #rest) *
    (#rest_start == start + 1) *
    (#rest_length == contentsLength - 1) *
    DataProp(a, #index, #ui8a) *
    Uint8Array (#ui8a, #ab, 0, #viewSize) *
    ArrayBuffer(#ab, #element) *
    (#viewSize == l-len #element) *
    ArrayOfUInt8ArraysContents(a, #rest, #rest_start, #rest_length);

pred ArrayOfUInt8Arrays (+a:Obj, contents:List, arrayLength:Num) :
    ArrayStructure(a, arrayLength) *
    ArrayOfUInt8ArraysContents(a, contents, 0, arrayLength);

(* ----------------------------------------------------------------------------------- *)

pred ArrayOfArraysOfUInt8ArraysContents(+a:Obj, contents:List, +start:Num, contentsLength:Num) :
    (contents == {{ }}) * (contentsLength == 0),

    (#index == num_to_string start) *
    (contents == #elementContents :: #rest) *
    DataProp(a, #index, #aui8a) *
    ArrayOfUInt8Arrays (#aui8a, #elementContents, _) *
    (contentsLength == l-len contents) *
    (#rest_start == start + 1) *
    (#rest_contents == contentsLength - 1) *
    ArrayOfArraysOfUInt8ArraysContents(a, #rest, #rest_start, #rest_contents);

pred ArrayOfArraysOfUInt8Arrays (+a:Obj, contents:List, arrayLength:Num) :
    ArrayStructure(a, arrayLength) *
    ArrayOfArraysOfUInt8ArraysContents(a, contents, 0, arrayLength);

(**************************
 **** Array Prototype  ****
 **************************)

nounfold pred ArrayPrototype (proto) :
  JSObjWithProto (proto, $lobj_proto) *
  empty_fields (proto : -{ "push", "map" }-) *

  ((proto, "push") -> {{ "d", $lap_push, true, false, true }}) * (* Array.prototype.push  *)
  ((proto, "map")  -> {{ "d", $lap_map,  true, false, true }}) * (* Array.prototype.map   *)

  JSBIFunction($lap_push, "AP_push", 1) * (* Actual push function *)
    empty_fields($lap_push : -{ "length" }-) *
  JSBIFunction($lap_map, "AP_map", 1) *  (* Actual map function *)
    empty_fields($lap_map : -{ "length" }-);

(*******************************************************************
 **** Axiomatic specifications of the Array prototype functions ****
 *******************************************************************)

only spec AP_push (xsc, vthis, element)
    [[ (vthis == #vthis) * (element == #ui8a) *
       Uint8Array (#ui8a, #ab, 0, #viewSize) *
       ArrayBuffer(#ab, #element) *
       (#viewSize == l-len #element) *
       ArrayOfUInt8Arrays(#vthis, #contents, #arraylength) ]]
    [[ ArrayOfUInt8Arrays(#vthis, l+ (#contents, {{ #element }}), #arraylength + 1) * (ret == undefined) ]]
    normal;

    [[ (vthis == #vthis) * (element == #aui8a) *
       ArrayOfUInt8Arrays (#aui8a, #aContents, _) *
       ArrayOfArraysOfUInt8Arrays(#vthis, #contents, #arraylength) ]]
    [[ ArrayOfArraysOfUInt8Arrays(#vthis, l+ (#contents, {{ #aContents }}), #arraylength + 1) * (ret == undefined) ]]
    normal

(********************************
 **** The Elements Predicate ****
 ********************************)

pred Element(+view:List, +readPos:Num, +fieldCount: Num, fieldList:List, elementLength:Num) :
    (0 <=# readPos) * (fieldCount == 0) * (fieldList == {{ }}) * (elementLength == 0) *
    (readPos + elementLength <=# l-len view),

    (0 <=# readPos) * (0 <# fieldCount) * (0 <# elementLength) *
    (#rawFL == l-sub (view, readPos, 2)) *
    rawToUInt16(#rawFL, false, #fieldLength) *
    (#field == l-sub(view, readPos + 2, #fieldLength)) *
    (#restFieldCount == fieldCount - 1) *
    Element(view, readPos + 2 + #fieldLength, #restFieldCount, #restFields, #restElementLength) *
    (0 <=# #restElementLength) *
    (fieldList == #field :: #restFields) *
    (elementLength == 2 + #fieldLength + #restElementLength) *
    (readPos + elementLength <=# l-len view);

pred Elements(+view:List, +readPos:Num, +elementCount: Num, +fieldCount: Num, elementList:List, elementsLength:Num) :
    (0 <=# readPos) * (elementCount == 0) * (0 <# fieldCount) * (elementList == {{ }}) * (elementsLength == 0) *
    (readPos + elementsLength <=# l-len view),

    (0 <=# readPos) * (0 <# elementCount) * (0 <# fieldCount) * (0 <# elementsLength) *
    Element(view, readPos, fieldCount, #element, #elementLength) *
    (#restElementCount == elementCount - 1) *
    Elements(view, readPos + #elementLength, #restElementCount, fieldCount, #restElements, #restElementsLength) *
    (0 <=# #restElementsLength) *
    (elementList == #element :: #restElements) *
    (elementsLength == #elementLength + #restElementsLength) *
    (readPos + elementsLength <=# l-len view);

lemma ElementPureFacts(view, readPos, fieldCount, fieldList, elementLength)
    [[ (view == #view) * (readPos == #readPos) * (fieldCount == #fieldCount) *
       (fieldList == #fieldList) * (elementLength == #elementLength) *
       Element (#view, #readPos, #fieldCount, #fieldList, #elementLength) ]]
    [[ Element (#view, #readPos, #fieldCount, #fieldList, #elementLength) *
       (0 <=# #readPos) *
       (0 <=# #fieldCount) *
       (0 <=# #elementLength) *
       (#readPos + #elementLength <=# l-len #view) ]]
[*
    unfold Element (#view, #readPos, #fieldCount, #fieldList, #elementLength)
 *]

lemma ElementsPureFacts(view, readPos, elementCount, fieldCount, elementList, elementsLength)
    [[ (view == #view) * (readPos == #readPos) * (elementCount == #elementCount) *
       (fieldCount == #fieldCount) * (elementList == #elementList) * (elementsLength == #elementsLength) *
       Elements (#view, #readPos, #elementCount, #fieldCount, #elementList, #elementsLength) ]]
    [[ Elements (#view, #readPos, #elementCount, #fieldCount, #elementList, #elementsLength) *
       (0 <=# #readPos) *
       (0 <# #fieldCount) *
       (0 <=# #elementCount) *
       (0 <=# #elementsLength) *
       (#readPos + #elementsLength <=# l-len #view) ]]
[*
    unfold Elements(#view, #readPos, #elementCount, #fieldCount, #elementList, #elementLength)
 *]

lemma ElementsAppend(view, readPos, elementCount, fieldCount, elementList, elementsLength, fieldList, elementLength)
    [[ (view == #view) * (readPos == #readPos) * (elementCount == #elementCount) *
        (fieldCount == #fieldCount) * (elementList == #elementList) * (elementsLength == #elementsLength) *
        (fieldList == #fieldList) * (elementLength == #elementLength) *
        Elements(#view, #readPos, #elementCount, #fieldCount, #elementList, #elementsLength) *
        Element (#view, #readPos + #elementsLength, #fieldCount, #fieldList, #elementLength) ]]
    [[ Elements(#view, #readPos, #elementCount + 1, #fieldCount, l+ (#elementList, {{ #fieldList }}), #elementsLength + #elementLength) ]]
[*
    sep_apply ElementsPureFacts(#view, #readPos, #elementCount, #fieldCount, #elementList, #elementsLength);
    unfold Elements(#view, #readPos, #elementCount, #fieldCount, #elementList, #elementsLength);
    if (#elementCount = 0) then {
      sep_assert (0 == 0)
    } else {
      sep_assert (Element(#view, #readPos, #fieldCount, #newElementFieldList, #newElementLength)) [bind: #newElementFieldList, #newElementLength];
      sep_apply ElementPureFacts(#view, #readPos, #fieldCount, #newElementFieldList, #newElementLength);
      sep_assert (Elements(#view, (#readPos + #newElementLength), (#elementCount - 1), #fieldCount, #remainingElementsList, #remainingElementsLength)) [bind: #remainingElementsList, #remainingElementsLength];
      sep_apply ElementsAppend(#view, (#readPos + #newElementLength), (#elementCount - 1), #fieldCount, #remainingElementsList, #remainingElementsLength, #fieldList, #elementLength);
      fold Elements(#view, #readPos, #elementCount + 1, #fieldCount, l+ (#elementList, {{ #fieldList }}), #elementsLength + #elementLength)
    }
 *]