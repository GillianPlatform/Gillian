(******************
 **** ELEMENTS ****
 ******************)

pred Field(+buffer:List, +readPos:Num, field:List, fLength:Num) :
    (#rawFL == l-sub (buffer, readPos, 2)) *
    rawToUInt16(#rawFL, false, fLength) *
    (field == l-sub(buffer, readPos + 2, fLength));

lemma FieldPureFacts(buffer, readPos, field, fLength)
  [[ (buffer == #buffer) * (readPos == #readPos) * (field == #field) * (fLength == #fLength) *
     Field(#buffer, #readPos, #field, #fLength) ]]
  [[ Field(#buffer, #readPos, #field, #fLength) *
     (0 <=# #fLength) ]]
  [* *]

pred CElement(+buffer:List, +readPos:Num, +fCount: Num, fList:List, eLength:Num) :
    (0 <=# readPos) * (readPos <=# l-len buffer) * (fCount == 0) * (fList == {{ }}) * (eLength == 0),

    (0 <=# readPos) * (readPos <=# l-len buffer) * (0 <# fCount) *
    Field(buffer, readPos, #field, #fLength) *
    (#restFCount == fCount - 1) *
    CElement(buffer, readPos + 2 + #fLength, #restFCount, #restFields, #restELength) *
    (fList == #field :: #restFields) *
    (eLength == 2 + #fLength + #restELength) *
    (readPos + eLength <=# l-len buffer);

lemma CElementPureFacts(buffer, readPos, fCount, fList, eLength)
    [[ (buffer == #buffer) * (readPos == #readPos) * (fCount == #fCount) * (fList == #fList) * (eLength == #eLength) *
       CElement(#buffer, #readPos, #fCount, #fList, #eLength) ]]
    [[ CElement(#buffer, #readPos, #fCount, #fList, #eLength) *
       (0 <=# #readPos) * (#readPos <=# l-len #buffer) * (0 <=# #fCount) * (0 <=# #eLength) *
       (#readPos + #eLength <=# l-len #buffer) ]]
    [*
      unfold CElement(#buffer, #readPos, #fCount, #fList, #eLength);
      if (0 < #fCount) then {
        sep_assert (Field(#buffer, #readPos, #field, #fLength)) [bind: #field, #fLength];
        sep_apply FieldPureFacts(#buffer, #readPos, #field, #fLength);
        sep_assert (CElement(#buffer, #readPos + 2 + #fLength, #fCount - 1, #restFields, #restELength)) [bind: #restFields, #restELength];
        sep_apply CElementPureFacts(#buffer, #readPos + 2 + #fLength, #fCount - 1, #restFields, #restELength)
      }
     *]

lemma NonEmptyCElementLength(buffer, readPos, fCount, field, restFields, eLength)
    [[ (buffer == #buffer) * (readPos == #readPos) * (fCount == #fCount) *
       (field == #field) * (restFields == #restFields) * (eLength == #eLength) *
       CElement(#buffer, #readPos, #fCount, l+({{ #field }}, #restFields), #eLength) ]]
    [[ CElement(#buffer, #readPos, #fCount, l+({{ #field }}, #restFields), #eLength) *
       (2 + l-len #field <=# #eLength) ]]
    [*
      unfold CElement(#buffer, #readPos, #fCount, l+({{ #field }}, #restFields), #eLength);
      sep_assert (Field(#buffer, #readPos, #field, #fLength)) [bind: #fLength];
      sep_assert (CElement(#buffer, #readPos + 2 + #fLength, #fCount - 1, #restFields, #restELength)) [bind: #restELength];
      sep_apply CElementPureFacts(#buffer, #readPos + 2 + #fLength, #fCount - 1, #restFields, #restELength)
     *]

lemma PositiveCElementLength(buffer, readPos, fCount, fList, eLength)
    [[ (buffer == #buffer) * (readPos == #readPos) * (fCount == #fCount) * (fList == #fList) * (eLength == #eLength) *
       CElement(#buffer, #readPos, #fCount, #fList, #eLength) * (0 <# #fCount) ]]
    [[ CElement(#buffer, #readPos, #fCount, #fList, #eLength) *
       (0 <# #eLength) ]]
    [*
      unfold CElement(#buffer, #readPos, #fCount, #fList, #eLength);
      sep_assert (Field(#buffer, #readPos, #field, #fLength)) [bind: #fLength];
      sep_assert (CElement(#buffer, #readPos + 2 + #fLength, #fCount - 1, #restFields, #restELength)) [bind: #restELength];
      sep_apply CElementPureFacts(#buffer, #readPos + 2 + #fLength, #fCount - 1, #restFields, #restELength)
     *]

lemma CElementAppend(buffer, readPos, fC1, fL1, eL1, fC2, field, fL2, eL2)
    [[ (buffer == #buffer) * (readPos == #readPos) * (fC1 == #fC1) * (fL1 == #fL1) * (eL1 == #eL1) *
       (fC2 == #fC2) * (field == #field) * (fL2 == #fL2) * (eL2 == #eL2) *
       CElement(#buffer, #readPos, #fC1, #fL1, #eL1) *
       CElement(#buffer, #readPos + #eL1, #fC2, l+({{ #field }}, #fL2), #eL2) *
       (#shift == 2 + l-len #field) ]]
    [[ CElement(#buffer, #readPos, #fC1 + 1, l+ (#fL1, {{ #field }}), #eL1 + #shift) *
       CElement(#buffer, #readPos + #eL1 + #shift, #fC2 - 1, #fL2, #eL2 - #shift) ]]
  [*
    sep_apply CElementPureFacts(#buffer, #readPos, #fC1, #fL1, #eL1);
    sep_apply CElementPureFacts(#buffer, #readPos + #eL1, #fC2, l+({{ #field }}, #fL2), #eL2);
    sep_apply NonEmptyCElementLength(#buffer, #readPos + #eL1, #fC2, #field, #fL2, #eL2);
    unfold CElement(#buffer, #readPos, #fC1, #fL1, #eL1);
    if (not (#fC1 = 0)) then {
      sep_assert (#fL1 == l+ ({{ #fl1 }}, #rfl1)) [bind: #fl1, #rfl1];
      sep_assert (CElement(#buffer, 2 + (l-len #fl1) + #readPos, #fC1 - 1, #rfl1, #reL1)) [bind: #reL1];
      sep_apply CElementPureFacts(#buffer, 2 + (l-len #fl1) + #readPos, #fC1 - 1, #rfl1, #reL1);
      sep_apply CElementAppend(#buffer, 2 + (l-len #fl1) + #readPos, #fC1 - 1, #rfl1, #reL1, #fC2, #field, #fL2, #eL2);
      fold CElement(#buffer, #readPos, #fC1 + 1, l+ (#fL1, {{ #field }}), #eL1 + #shift)
    }
  *]

pred CElements(+buffer:List, +readPos:Num, +elementCount: Num, +fieldCount: Num, elementsList:List, elementsLength:Num) :
    (0 <=# readPos) * (elementCount == 0) * (0 <# fieldCount) * (elementsList == {{ }}) * (elementsLength == 0) *
    (readPos + elementsLength <=# l-len buffer),

    (0 <=# readPos) * (0 <# elementCount) * (0 <# fieldCount) * (0 <# elementsLength) *
    CElement(buffer, readPos, fieldCount, #fieldsList, #elementLength) *
    (#restElementCount == elementCount - 1) *
    CElements(buffer, readPos + #elementLength, #restElementCount, fieldCount, #restElements, #restElementsLength) *
    (0 <=# #restElementsLength) *
    (elementsList == #fieldsList :: #restElements) *
    (elementsLength == #elementLength + #restElementsLength) *
    (readPos + elementsLength <=# l-len buffer);

lemma CElementsPureFacts(buffer, readPos, eCount, fCount, eList, esLength)
    [[ (buffer == #buffer) * (readPos == #readPos) * (eCount == #eCount) * (fCount == #fCount) * (eList == #eList) * (esLength == #esLength) *
       CElements(#buffer, #readPos, #eCount, #fCount, #eList, #esLength) ]]
    [[ CElements(#buffer, #readPos, #eCount, #fCount, #eList, #esLength) *
       (0 <=# #readPos) * (#readPos <=# l-len #buffer) * (0 <=# eCount) * (0 <# #fCount) * (0 <=# #esLength) *
       (#readPos + #esLength <=# l-len #buffer) ]]
    [* *]

lemma CElementsAppend(buffer, readPos, eCount, fCount, eList, esLength, fList, eLength)
    [[ (buffer == #buffer) * (readPos == #readPos) * (eCount == #eCount) *
       (fCount == #fCount) * (eList == #eList) * (esLength == #esLength) *
       (fList == #fList) * (eLength == #eLength) *
       CElements(#buffer, #readPos, #eCount, #fCount, #eList, #esLength) *
       CElement(#buffer, #readPos + #esLength, #fCount, #fList, #eLength) ]]
    [[ CElements(#buffer, #readPos, #eCount + 1, #fCount, l+ (#eList, {{ #fList }}), #esLength + #eLength) ]]
[*
    sep_apply CElementsPureFacts(#buffer, #readPos, #eCount, #fCount, #eList, #esLength);
    sep_apply CElementPureFacts(#buffer, #readPos + #esLength, #fCount, #fList, #eLength);
    sep_apply PositiveCElementLength(#buffer, #readPos + #esLength, #fCount, #fList, #eLength);
    unfold CElements(#buffer, #readPos, #eCount, #fCount, #eList, #esLength);
    if (not (#eCount = 0)) then {
      sep_assert (CElement(#buffer, #readPos, #fCount, #newElementFieldList, #newElementLength)) [bind: #newElementFieldList, #newElementLength];
      sep_apply CElementPureFacts(#buffer, #readPos, #fCount, #newElementFieldList, #newElementLength);
      sep_assert (CElements(#buffer, (#readPos + #newElementLength), (#eCount - 1), #fCount, #remainingElementsList, #remainingElementsLength)) [bind: #remainingElementsList, #remainingElementsLength];
      sep_apply CElementsAppend(#buffer, (#readPos + #newElementLength), (#eCount - 1), #fCount, #remainingElementsList, #remainingElementsLength, #fList, #eLength)
    }
 *]

(**************************
 *** INCOMPLETE ELEMENT ***
 **************************)

(* An element that cannot be read from a given buffer of data *)
pred IElement(+buffer:List, +readPos:Num, +fCount: Num, fList:List, eLength:Num) :
    (* Base case: not enough data to read length of next field *)
    (0 <=# readPos) * (0 <# fCount) *
    (readPos <=# l-len buffer) * (l-len buffer <# readPos + 2) *
    (fList == {{ }}) * (eLength == l-len buffer - readPos),

    (* Base case: enough data to read length of next field, but not enough data to read next field *)
    (0 <=# readPos) * (0 <# fCount) * (readPos + 2 <=# l-len buffer) *
    (#rawFL == l-sub (buffer, readPos, 2)) *
    rawToUInt16(#rawFL, false, #fLength) *
    (l-len buffer <# readPos + 2 + #fLength) *
    (fList == {{ }}) * (eLength == l-len buffer - (readPos + 2)),

    (* Recursive case: enough data to read one field, but not enough data to read the remaining ones *)
    (0 <=# readPos) * (1 <# fCount) *
    Field(buffer, readPos, #field, #fLength) *
    (#restFCount == fCount - 1) *
    (readPos + 2 + #fLength <=# l-len buffer) *
    IElement(buffer, readPos + 2 + #fLength, #restFCount, #restFList, #restELength) *
    (fList == #field :: #restFList) *
    (eLength == 2 + #fLength + #restELength);

lemma IElementPureFacts(buffer, readPos, fCount, fList, eLength)
    [[ (buffer == #buffer) * (readPos == #readPos) * (fCount == #fCount) * (fList == #fList) * (eLength == #eLength) *
       IElement(#buffer, #readPos, #fCount, #fList, #eLength) ]]
    [[ IElement(#buffer, #readPos, #fCount, #fList, #eLength) *
       (0 <=# #readPos) * (#readPos <=# l-len #buffer) * (0 <# #fCount) * (0 <=# #eLength) ]]
    [*
      unfold IElement(#buffer, #readPos, #fCount, #fList, #eLength);
      if (not (#fList = {{ }})) then {
        sep_assert (Field(#buffer, #readPos, #field, #fLength)) [bind: #field, #fLength];
        sep_apply FieldPureFacts(#buffer, #readPos, #field, #fLength);
        sep_assert (IElement(#buffer, #readPos + 2 + #fLength, #fCount - 1, #restFields, #restELength)) [bind: #restFields, #restELength];
        sep_apply IElementPureFacts(#buffer, #readPos + 2 + #fLength, #fCount - 1, #restFields, #restELength)
      }
     *]

(***************************
 *** INCOMPLETE ELEMENTS ***
 ***************************)

(* A sequence of elements that cannot be read from a given buffer of data *)
pred IElements(+buffer:List, +readPos:Num, +eCount: Num, +fCount: Num, eList:List, esLength:Num) :
  (* Base case: single incomplete element *)
  (0 <=# readPos) * (readPos <=# l-len buffer) * (0 <# eCount) * (0 <# fCount) *
  IElement(buffer, readPos, fCount, #fList, esLength) * eList == {{ }},

  (* Recursive case: enough data to read first element, but not enough data to read the remaining ones *)
  (0 <=# readPos) * (readPos <=# l-len buffer) * (1 <# eCount) * (0 <# fCount) *
  CElement(buffer, readPos, fCount, #fList, #eLength) *
  (#restECount == eCount - 1) *
  IElements(buffer, readPos + #eLength, #restECount, fCount, #restEList, #restESLength) *
  (eList == #fList :: #restEList) *
  (esLength == #eLength + #restESLength);

lemma IElementsPureFacts(buffer, readPos, eCount, fCount, eList, esLength)
    [[ (buffer == #buffer) * (readPos == #readPos) * (eCount == #eCount) * (fCount == #fCount) * (eList == #eList) * (esLength == #esLength) *
       IElements(#buffer, #readPos, #eCount, #fCount, #eList, #esLength) ]]
    [[ IElements(#buffer, #readPos, #eCount, #fCount, #eList, #esLength) *
       (0 <=# #readPos) * (#readPos <=# l-len #buffer) * (0 <# eCount) * (0 <# #fCount) * (0 <=# #esLength) ]]
    [*
      unfold IElements(#buffer, #readPos, #eCount, #fCount, #eList, #esLength);
      if (#eList = {{ }}) then {
        sep_assert (IElement(#buffer, #readPos, #fCount, #fList, #esLength)) [bind : #fList];
        sep_apply IElementPureFacts(#buffer, #readPos, #fCount, #fList, #esLength)
      } else {
        sep_assert (CElement(#buffer, #readPos, #fCount, #fList, #eLength)) [bind : #fList, #eLength];
        sep_apply CElementPureFacts(#buffer, #readPos, #fCount, #fList, #eLength);
        sep_assert (IElements(#buffer, #readPos + #eLength, #eCount - 1, #fCount, #restEList, #restESLength)) [bind: #restEList, #restESLength];
        sep_apply IElementsPureFacts(#buffer, #readPos + #eLength, #eCount - 1, #fCount, #restEList, #restESLength)
      }
    *]

(************************
 *** GENERAL ELEMENTS ***
 ************************)

nounfold pred Element(definition:Str, +buffer:List, +readPos:Num, +fCount: Num, fList:List, eLength:Num) :
      (definition == "Complete")   * CElement(buffer, readPos, fCount, fList, eLength),
      (definition == "Incomplete") * IElement(buffer, readPos, fCount, fList, eLength);

nounfold pred Elements(definition:Str, +buffer:List, +readPos:Num, +eCount: Num, +fCount: Num, eList:List, esLength:Num) :
      (definition == "Complete")   * CElements(buffer, readPos, eCount, fCount, eList, esLength),
      (definition == "Incomplete") * IElements(buffer, readPos, eCount, fCount, eList, esLength);

lemma ElementsPureFacts(buffer, readPos, eCount, fCount, eList, esLength)
    [[ (buffer == #buffer) * (readPos == #readPos) * (eCount == #eCount) *
       (fCount == #fCount) * (eList == #eList) * (esLength == #esLength) *
       Elements(#definition, #buffer, #readPos, #eCount, #fCount, #eList, #esLength) ]]
    [[
       (#definition == "Complete") *
       Elements(#definition, #buffer, #readPos, #eCount, #fCount, #eList, #esLength) *
       (0 <=# #readPos) * (#readPos <=# l-len #buffer) *
       (0 <=# #eCount) * (0 <# #fCount) * (0 <=# #esLength);

       (#definition == "Incomplete") *
       Elements(#definition, #buffer, #readPos, #eCount, #fCount, #eList, #esLength) *
       (0 <=# #readPos) * (#readPos <=# l-len #buffer) *
       (0 <# #eCount) * (0 <# #fCount) * (0 <=# #esLength)
    ]]
    [*
      unfold Elements(#definition, #buffer, #readPos, #eCount, #fCount, #eList, #esLength);
      if (#definition = "Complete") then {
        sep_apply CElementsPureFacts(#buffer, #readPos, #eCount, #fCount, #eList, #esLength)
      } else {
        sep_apply IElementsPureFacts(#buffer, #readPos, #eCount, #fCount, #eList, #esLength)
      }
    *]

(****************************
**** ENCRYPTED DATA KEYS ****
*****************************)

nounfold pred CRawEncryptedDataKeys(+rawHeaderData:List, +start:Num, keyCount:Num, EDKs:List, EDKsLength:Num) :
    (0 <=# start) * (start <=# l-len rawHeaderData) *
    (#rawEC == l-sub (rawHeaderData, start, 2)) *
    rawToUInt16(#rawEC, false, keyCount) *
    (0 <# keyCount) *
    Elements("Complete", rawHeaderData, start + 2, keyCount, 3, EDKs, #EDKsLength) *
    (EDKsLength == #EDKsLength + 2) *
    (start + EDKsLength <=# l-len rawHeaderData);

nounfold pred IRawEncryptedDataKeys(+rawHeaderData:List, +start:Num) :
    (0 <=# start) * (start <=# l-len rawHeaderData) * (l-len rawHeaderData <# start + 2),

    (0 <=# start) * (start + 2 <=# l-len rawHeaderData) *
    (#rawEC == l-sub (rawHeaderData, start, 2)) *
    rawToUInt16(#rawEC, false, #keyCount) *
    (0 <# #keyCount) *
    Elements("Incomplete", rawHeaderData, start + 2, #keyCount, 3, #eList, #esLength);

nounfold pred BRawEncryptedDataKeys(errorMessage: Str, +rawHeaderData:List, +start:Num) :
    ((start <# 0) \/ (l-len rawHeaderData <# start)) * (errorMessage == "deserializeMessageHeader: startPos out of bounds."),

    (0 <=# start) * (start + 2 <=# l-len rawHeaderData) *
    (#rawEC == l-sub (rawHeaderData, start, 2)) *
    rawToUInt16(#rawEC, false, 0) *
    (errorMessage == "Malformed Header: No EncryptedDataKey found.");

pred RawEncryptedDataKeys(definition:Str, +rawHeaderData:List, +start:Num, keyCount:Num, EDKs:List, EDKsLength:Num, errorMessage:Str) :
  (definition == "Complete") * CRawEncryptedDataKeys(rawHeaderData, start, keyCount, EDKs, EDKsLength) * (errorMessage == ""),
  (definition == "Incomplete") * IRawEncryptedDataKeys(rawHeaderData, start) * (keyCount == 0) * (EDKs == {{ }}) * (EDKsLength == 0) * (errorMessage == ""),
  (definition == "Broken") * BRawEncryptedDataKeys(errorMessage, rawHeaderData, start) * (keyCount == 0) * (EDKs == {{ }}) * (EDKsLength == 0);

(****************************
**** toUTF8 and fromUtf8 ****
*****************************)

(* FIXME: toUt8 is abstract *)
pure nounfold pred toUtf8(+rawData:List, utf8Data:Str) : (utf8Data == "");

(* toUtf8 is injective *)
lemma toUtf8Injective(rawData1, utf8Data1, rawData2, utf8Data2)
    [[ (rawData1 == #rawData1) * (utf8Data1 == #utf8Data1) *
       (rawData2 == #rawData2) * (utf8Data2 == #utf8Data2) *
       toUtf8(#rawData1, #utf8Data1) * toUtf8(#rawData2, #utf8Data2) ]]
    [[ (#rawData1 == #rawData2) * (#utf8Data1 == #utf8Data2);
       (! (#rawData1 == #rawData2)) * (! (#utf8Data1 == #utf8Data2)) ]]

(* FIXME: fromUt8 is abstract *)
pure nounfold pred fromUtf8(+utf8Data:Str, rawData:List) : (rawData == {{ }});

(* toUtf8 is injective *)
lemma fromUtf8Injective(utf8Data1, rawData1, utf8Data2, rawData2)
    [[ (utf8Data1 == #utf8Data1) * (rawData1 == #rawData1) *
       (utf8Data2 == #utf8Data2) * (rawData2 == #rawData2) *
       fromUtf8(#utf8Data1, #rawData1) * fromUtf8(#utf8Data2, #rawData2) ]]
    [[ (#utf8Data1 == #utf8Data2) * (#rawData1 == #rawData2);
       (! (#utf8Data1 == #utf8Data2)) * (! (#rawData1 == #rawData2)) ]]

(* Invertibility to -> from *)
lemma toUtf8fromUtf8(rawData)
  [[ (rawData == #rawData) * toUtf8(#rawData, #utf8Data) ]]
  [[ fromUtf8(#utf8Data, #rawData) ]]

(* Invertibility from -> to *)
lemma fromUtf8toUtf8(utf8Data)
  [[ (utf8Data == #utf8Data) * fromUtf8(#utf8Data, #rawData) ]]
  [[ toUtf8(#rawData, #utf8Data) ]]

(**************************************
 **** Arrays of EncryptedDataKeys  ****
 **************************************)

pred ArrayOfEDKsContents(+a:Obj, contents:List, +start:Num, +contentsLength:Num) :
    (contents == {{ }}) * (contentsLength == 0),

    (#index == num_to_string start) *
    DataProp(a, #index, #edk) *
    EncryptedDataKey(#edk, #pId, #pInfo, #encryptedDataKey, #rawInfo) *
    fromUtf8(#rawId, #pId) * fromUtf8(#pInfo, #rawInfo) *
    (#element == {{ #rawId, #rawInfo, #encryptedDataKey }}) *
    (contentsLength == l-len contents) *
    (contents == #element :: #rest) *
    (#rest_start == start + 1) *
    (#rest_length == contentsLength - 1) *
    ArrayOfEDKsContents(a, #rest, #rest_start, #rest_length);

pred PreDecodedEncryptedDataKeys (+a:Obj, EDKs:List, arrayLength:Num) :
    ArrayStructure(a, arrayLength) *
    ArrayOfEDKsContents(a, EDKs, 0, arrayLength);

pred FrozenArrayOfEDKsContents(+a:Obj, contents:List, +start:Num, +contentsLength:Num) :
    (contents == {{ }}) * (contentsLength == 0),

    (#index == num_to_string start) *
    readOnlyProperty(a, #index, #edk) *
    EncryptedDataKey(#edk, #pId, #pInfo, #encryptedDataKey, #rawInfo) *
    fromUtf8(#rawId, #pId) * fromUtf8(#pInfo, #rawInfo) *
    (#edk == {{ #rawId, #rawInfo, #encryptedDataKey }}) *
    (contentsLength == l-len contents) *
    (contents == #edk :: #rest_contents) *
    (#rest_start == start + 1) *
    (#rest_length == contentsLength - 1) *
    FrozenArrayOfEDKsContents(a, #rest_contents, #rest_start, #rest_length);

pred DecodedEncryptedDataKeys (+a:Obj, contents:List, arrayLength:Num) :
    FrozenArrayStructure(a, arrayLength) *
    FrozenArrayOfEDKsContents(a, contents, 0, arrayLength);

(* ************************** *)
(* *** ENCRYPTION CONTEXT *** *)
(* ************************** *)

nounfold pred CRawEncryptionContext(+EC:List, ECKs:List) :
    (l-len EC == 2) * (ECKs == {{ }}) * rawToUInt16(EC, false, 0),

    (2 <# l-len EC) *
    (#rawKC == l-sub (EC, 0, 2)) *
    rawToUInt16(#rawKC, false, #keyCount) *
    (0 <# #keyCount) *
    Elements("Complete", EC, 2, #keyCount, 2, ECKs, #ECKsLength) *
    (2 + #ECKsLength == l-len EC);

nounfold pred BRawEncryptionContext(errorMessage:Str, +EC:List) :
    (2 <# l-len EC) *
    (#rawKC == l-sub (EC, 0, 2)) *
    rawToUInt16(#rawKC, false, #keyCount) *
    (0 <# #keyCount) *
    Elements("Incomplete", EC, 2, #keyCount, 2, #eList, #esLength) *
    (errorMessage == "decodeEncryptionContext: Underflow, not enough data."),

    (2 <# l-len EC) *
    (#rawKC == l-sub (EC, 0, 2)) *
    rawToUInt16(#rawKC, false, #keyCount) *
    (0 <# #keyCount) *
    Elements("Complete", EC, 2, #keyCount, 2, #ECKs, #ECKsLength) *
    (! (#ECKsLength + 2 == l-len EC)) *
    (errorMessage == "decodeEncryptionContext: Overflow, too much data.");

pred RawEncryptionContext(definition:Str, +EC:List, ECKs:List, errorMessage:Str) :
  (definition == "Complete") * CRawEncryptionContext(EC, ECKs) * (errorMessage == ""),
  (definition == "Broken")   * BRawEncryptionContext(errorMessage, EC) * (ECKs == {{ }});

pred DecodedEncryptionContext(+dECObj : Obj) :
    JSObjWithProto(dECObj, null);

(* ********************* *)
(* *** OBJECT_FREEZE *** *)
(* ********************* *)

only spec Object_freeze(xsc, vthis, l)

  [[ (l == #l) * PreDecodedEncryptedDataKeys(#l, #EDKs, #keyCount) ]]
  [[ DecodedEncryptedDataKeys(#l, #EDKs, #keyCount) * (ret == #l) ]]
  normal

    nounfold pred EncryptedDataKey(+EDK, pId:Str, pInfo:Str, encryptedDataKey:List, rawInfo:List) :
        JSObjGeneral(EDK, $l_edk_proto, "Object", false) *
        readOnlyProperty(EDK, "providerId", pId) *
        readOnlyProperty(EDK, "providerInfo", pInfo) *
        readOnlyProperty(EDK, "encryptedDataKey", #aEDK) *
            Uint8Array(#aEDK, #abEDK, 0, #viewSizeEDK) *
            ArrayBuffer(#abEDK, encryptedDataKey) *
            (#viewSizeEDK == l-len encryptedDataKey) *
        readOnlyProperty(EDK, "rawInfo", #aRInfo) *
            Uint8Array(#aRInfo, #abRInfo, 0, #viewSizeRInfo) *
            ArrayBuffer(#abRInfo, rawInfo) *
            (#viewSizeRInfo == l-len rawInfo);