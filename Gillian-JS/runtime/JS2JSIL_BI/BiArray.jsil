import Internals.jsil;

(* ***************** *)
(* THE ARRAY LIBRARY *)
(* ***************** *)

(* *** CONSTRUCT *** *)

proc Array_call () {
        arguments := args;
        params := "Array_construct" :: arguments;
        ret := apply(params) with elab;

  rlab: return;
  elab: throw
};

(** Array Constructor (inner function of Array_call)
  Runtime arguments:
  1. xsc: Current scope chain
  2. vthis: Resolved thisArg for the function call
  3. Optional arguments, either of form:
    (a) [len]: Length of new array to create
    (b) [... items]: item(s) to initialise in the array

  Note: We skip the first three arguments because we do not use
  them for the Array constructor (they are passed in as part of
  a standard function call). So theoretically, you can pass in
  anything in the first three arguments and it would still work.
*)
proc Array_construct (xsc, vthis) {
            (* Default array construction *)
            array := "create_default_object" ($larr_proto, "Array", true);
            [array, "length"] := {{ "d", 0, true, false, true }};

            (* All runtime arguments *)
            arguments := args;
            (* Optional arguments (4) *)
            opt_args := cdr (cdr arguments);
            len := l-len (opt_args);
            goto [len = 0] rlab ltest;
  ltest:    goto [len = 1] arr_a arr_b;

            (* Form 4(a): new Array(len) *)
  arr_a:    len := l-nth (opt_args, 0);
            prop_name := "length";
            prop_num := "0";
            goto [typeOf len = Num] check set;
  check:    len_32 := "i__toUint32" (len) with elab;
            goto [len = len_32] set thrw;

  set:      PHI(prop_a: prop_num, prop_name; enum: true, false);
            ret_def_a := "a__defineOwnProperty" (array, prop_a, {{ "d", len, true, enum, true }}, true) with elab;
            goto rlab;

            (* Form 4(b): new Array([item1 [, item2 [, ...]]] *)
  arr_b:    start_n := 0;
  loop:	    PHI(n: start_n, next_n);
            goto [n < len] head rlab;
  head:     prop_b := "i__toString" (n) with elab;
            prop_val := l-nth (opt_args, n);
            ret_def_b := "a__defineOwnProperty" (array, prop_b, {{ "d", prop_val, true, true, true }}, true) with elab;
            next_n := n + 1;
            goto loop;

            (* Normal return *)
  rlab:	    ret := array;
            return;

            (* Error return *)
  thrw:     range_err := "RangeError" ();
  elab:     PHI(ret: len_32, ret_def_a, prop, ret_def_b, range_err);
            throw
};

(* *** ISIDX *** *)

proc a__isIdx (s) {
			ret := "i__toUint32" (s) with elab;
			ret := "i__toString" (ret) with elab;

			goto [ret = s] check ret_f;

	check:	ret := not (ret = "4294967295");
			goto rlab;

	ret_f:	ret := false;

	rlab: return;
	elab: throw
};

(* *** DEFINEOWNPROPERTY *** *)

proc a__defineOwnProperty (l, prop, desc, thrw) {

			oldLenDesc := "getOwnProperty" (l, "length");
			oldLen := l-nth (oldLenDesc, 1);
			ret := "i__toUint32" (oldLen) with elab;
			oldLenNum := ret;

			goto [prop = "length"] getall is_idx;

	is_idx:	idxp := "a__isIdx" (prop);
			goto [idxp] idx norm;

	idx:	index := "i__toUint32" (prop);
			index := index;
			oldLen := oldLen;
			ret := l-nth (oldLenDesc, 2);
			goto [(not (index < oldLenNum)) and (not (l-nth (oldLenDesc, 2)))] reject idop;
	idop:	ret := "o__defineOwnProperty" (l, prop, desc, false) with elab;
			goto [ret = false] reject ilen;
	ilen:	goto [not (index < oldLenNum)] setl rlab;
	setl:	ret := "o__defineOwnProperty" (l, "length", {{ "d", (index + 1), l-nth (oldLenDesc, 2), l-nth (oldLenDesc, 3), l-nth (oldLenDesc, 4) }}, false);
			goto rlab;

	norm:	ret := "o__defineOwnProperty" (l, prop, desc, thrw) with elab;
			goto rlab;

	getall:	goto [l-nth (desc, 0) = "d"] ddd odd;

			(* Data *)
	ddd:	de := l-nth (desc, 3);
			dc := l-nth (desc, 4);
			dv := l-nth (desc, 1);
			dw := l-nth (desc, 2);
			dg := empty;
			ds := empty;
			goto sla;

	odd:	goto [l-nth (desc, 0) = "a"] add gdd;

			(* Accessor *)
	add:	de := l-nth (desc, 3);
			dc := l-nth (desc, 4);
			dv := empty;
			dw := empty;
			dg := l-nth (desc, 1);
			ds := l-nth (desc, 2);
			goto sla;

			(* Generic *)
	gdd:	de := l-nth (desc, 1);
			dc := l-nth (desc, 2);
			dv := l-nth (desc, 3);
			dw := l-nth (desc, 4);
			dg := l-nth (desc, 5);
			ds := l-nth (desc, 6);

	sla:	goto [dv = empty] slai slb;

	slai:	ret := "o__defineOwnProperty" (l, "length", desc, thrw) with elab;
			goto rlab;

	slb:	ret := "i__toUint32" (dv) with elab;
			newLen := ret;
			ret := "i__toNumber" (dv) with elab;
			goto [not (newLen = ret)] rgerr sle;

	sle:	dv := newLen;
			goto [not (newLen < oldLenNum)] slfi slg;

	slfi:	ret := "o__defineOwnProperty" (l, "length", {{ "g", de, dc, dv, dw, dg, ds }}, thrw) with elab;
			goto rlab;

	slg:	goto [l-nth (oldLenDesc, 2) = false] reject slh;

	slh:	goto [dw = false] sli slh1;

	slh1:	newWritable := true;
			goto slj;

	sli:	newWritable := false;
			dw := true;

	slj:	ret := "o__defineOwnProperty" (l, "length", {{ "g", de, dc, dv, dw, dg, ds }}, thrw) with elab;
			goto [ret = false] tf loop;

	loop:	goto [newLen < oldLen] head slm;
	head:	oldLen := oldLen - 1;
			ret := "i__toString" (oldLen) with elab;
			ret := "deleteProperty" (l, ret, false) with elab;
			goto [ret = false] fix next;

	fix:	dv := oldLen + 1;
			goto [newWritable = false] setwr defl;
	setwr:	dw := false;
	defl:	ret := "o__defineOwnProperty" (l, "length", {{ "g", de, dc, dv, dw, dg, ds }}, thrw) with elab;
			goto reject;

	next:	goto loop;

	slm:	goto [newWritable = false] slmi sln;

	slmi:	ret := "o__defineOwnProperty" (l, "length", {{ "g", empty, empty, empty, false, empty, empty }}, false) with elab;

	sln:	ret := true;
	rlab: return;

	rgerr:	ret := "RangeError" ();
			goto elab;

	reject:	goto [thrw] tt tf;

	tt:		ret := "TypeError" ();
	elab: throw;

	tf:		ret := false;
			goto rlab
};

(* *** ISARRAY *** *)

proc Array_isArray (xsc, vthis, array) {
			ret := false;

			goto [typeOf (array) = Obj] cls rlab;

	cls:	m := metadata(array);
			class := [m, "@class"];
			goto [class = "Array"] rt rlab;

	rt:		ret := true;

	rlab: return;
	elab: throw
};

(* *** TOSTRING *** *)

proc AP_toString (xsc, vthis) {
          arr_obj := "i__toObject" (vthis) with elab;
          arr_join := "get" (arr_obj, "join") with elab;

          is_call := "i__isCallable" (arr_join);
          goto [is_call] norm setfun;

  setfun: op_toString := $lop_toString;

  norm:   PHI(f_o: arr_join, op_toString);
          m := metadata(f_o);
          xsc := [m, "@scope"];
          fun := [m, "@call"];
          ret_val := fun (xsc, arr_obj) with elab;
          goto [ret_val = empty] undef rlab;

  undef:  ret_def := undefined;

  rlab:   PHI(ret: ret_val, ret_def);
          return;

  elab:   PHI(ret: arr_obj, arr_join, ret_val);
          throw
};

(* *** JOIN *** *)

proc AP_join (xsc, vthis, sep) {
			ret := "i__toObject" (vthis) with elab;
			vthis := ret;

			ret := "get" ( vthis, "length") with elab;
			ret := "i__toLength" (ret) with elab;
			len := ret;

			goto [sep = undefined] ssep sssep;
	ssep:	sep := ",";
			goto len0;

	sssep:	ret := "i__toString" (sep) with elab;
			sep := ret;

	len0:	goto [len = 0] xemp non0;

	non0:	ret := "get" ( vthis, "0") with elab;
			goto [(ret = null) or (ret = undefined)] r0 rs;

	r0:		R := "";
			goto prep;

	rs:		ret := "i__toString" (ret) with elab;
			R := ret;

	prep:	k := 1;

	loop:	goto [k < len] head end;
	head:	R := R ++ sep;

			next := "";
			ret := "i__toString" (k) with elab;
			ret := "get" ( vthis, ret) with elab;

			goto [(ret = undefined) or (ret = null)] cc def;
	def:	ret := "i__toString" (ret) with elab;
			next := ret;

	cc:		R := R ++ next;
			k := k + 1;
			goto loop;


	end:	ret := R;
			goto rlab;

	xemp:	ret := "";

	rlab: return;
	elab: throw
};

(* *** POP *** *)
proc AP_pop (xsc, vthis) {
        arr_obj := "i__toObject" (vthis) with elab;

        len_val := "get" (arr_obj, "length") with elab;
        len := "i__toLength" (len_val) with elab;

        goto [len = 0] zero pop;

  zero:	put_len1 := "put" (arr_obj, "length", 0, true) with elab;
        ret_undef := undefined;
        goto rlab;

  pop:  indx := "i__toString" (len - 1);
        elem := "get" (arr_obj, indx) with elab;
        del_prop := "deleteProperty" (arr_obj, indx, true) with elab;
        put_len2 := "put" (arr_obj, "length", (len - 1), true) with elab;
        ret_elem := elem;

  rlab: PHI(ret: ret_undef, ret_elem);
        return;
  elab: PHI(ret: arr_obj, len_val, len, put_len1, elem, del_prop, put_len2);
        throw
};

(* *** PUSH *** *)
proc AP_push (xsc, vthis) {
        arguments := args;

        arr_obj := "i__toObject" (vthis) with elab;
        len_val := "get" (arr_obj, "length") with elab;
        len := "i__toLength" (len_val) with elab;

        items := cdr (cdr arguments);
        arg_count := l-len (items);

        (* ES6+: check if result length is greater than 2^53 - 1 *)
        (* Equiv number representation: 9007199254740991 *)
        goto [(len + arg_count) > $$max_safe_integer] thrw cont;

  cont: start := 0;
  loop:	PHI(i: start, next_i);
        goto [i < arg_count] add stop;

  add:  elem := l-nth (items, i);
        strn := "i__toString" (len);
        put_elem := "put" (arr_obj, strn, elem, true) with elab;
        len := len + 1;
        next_i := i + 1;
        goto loop;

  stop:	put_n := "put" (arr_obj, "length", len, true) with elab;
        ret := len;
  rlab: return;

  thrw: type_err := "TypeError" ();

  elab: PHI(ret: arr_obj, len_Val, len, put_elem, put_n, type_err);
        throw
};


(* *** TOLOCALESTRING *** *)
proc AP_toLocaleString(xsc, vthis) {
			ret := "i__toObject" (vthis) with elab;
			vthis := ret;

			ret := "get" ( vthis, "length") with elab;
			ret := "i__toLength" (ret) with elab;
			len := ret;

			sep := ",";
			k := 0;
			goto [len = 0] empt fill;

	empt:	ret := "";
			goto rlab;

	fill:	ret := "i__toString" (k) with elab;
			ret := "get" ( vthis, ret) with elab;
			goto [ (ret = undefined) or (ret = null) ] un def;

	un:		R := "";
			goto next;

	def:	ret := "i__toObject" (ret) with elab;
			eothis := ret;
			ret := "get" ( eothis, "toLocaleString") with elab;
			func := ret;

			ret := "i__isCallable" (func);
			goto [ret] call thrw;

	call:	m := metadata(func);
			xsc := [m, "@scope"];
			fun := [m, "@call"];
			ret := fun (xsc, eothis) with elab;
			goto [ret = empty] undef setR;
	undef:	ret := undefined;
	setR:	goto [ (ret = undefined) or (ret = null) ] un deff;

			(* This is not specified, but how do you concatenate non-strings? *)
	deff:	ret := "i__toString" (ret) with elab;
			R := ret;

	next:	goto [k = 0] fe ne;
	ne:		R := S ++ R;
	fe:		k := k + 1;
			goto loop;

	loop:	goto [k < len] lp end;

	lp:		S := R ++ sep;
			goto fill;

	end:	ret := R;
	rlab: return;

	thrw:	ret := "TypeError" ();
	elab: throw
};

(* *** CONCAT *** *)
proc AP_concat(xsc, vthis) {
          (* 0. Get the optional arguments *)
          arguments := args;
          opt_args := cdr (cdr arguments);

          (* 1. ToObject *)
          ret := "i__toObject" (vthis) with elab;
          vthis := ret;

          (* 2. Empty array (result to be) *)
          ret := "Array_construct" (empty, empty) with elab;
          A := ret;

          (* 3. Start from 0 *)
          n := 0;

          (* 4. Internal list over which to iterate *)
          opt_args := vthis :: opt_args;

          (* ++ Outer loop start: iterate over optional items given ++ *)
  loop:	  goto [opt_args = {{ }} ] end add;

  add:	  item := car opt_args;
          opt_args := cdr opt_args;

  cont:	  goto [typeOf (item) = Obj] cls narr;
  cls:    m := metadata(item);
          c := [m, "@class"];
          goto [c = "Array"] arr narr;

          (* item is an array object *)
  arr:    k := 0;
          ret := "get" (item, "length") with elab;
          len := ret;

          (* ++ Inner loop for array item ++ *)
  lp:     goto [k < len] loop2 loop;

  loop2:  ret := "i__toString" (k) with elab;
          p := ret;
          ret := "hasProperty" (item, p) with elab;
          goto [ret] tt next;

  tt:     ret := "get" ( item, p) with elab;
          se := ret;
          ret := "i__toString" (n) with elab;
          ret := "a__defineOwnProperty" (A, ret, {{ "d", se, true, true, true }}, false) with elab;

  next:   n := n + 1;
          k := k + 1;
          goto lp;

          (* item is NOT an array object *)
  narr:   ret := "i__toString" (n) with elab;
          ret := "a__defineOwnProperty" (A, ret, {{ "d", item, true, true, true }}, false) with elab;
          n := n + 1;
          goto loop;
          (* -- Outer loop end -- *)

          (* ES6+: Set length property directly *)
  end:    ret := "put" (A, "length", n, true) with elab;
          ret := A;

  rlab:   return;
  elab:   throw
};

(* *** REVERSE *** *)
proc AP_reverse(xsc, vthis) {
			ret := "i__toObject" (vthis) with elab;
			vthis := ret;

			ret := "get" ( vthis, "length") with elab;
			ret := "i__toLength" (ret) with elab;
			len := ret;

			mid := m_floor (len / 2);
			lower := 0;

	loop:	goto [not (mid = lower)] rev end;

	rev:	upper := (len - lower) - 1;
			ret := "i__toString" (upper) with elab;
			upperP := ret;
			ret := "i__toString" (lower) with elab;
			lowerP := ret;
			ret := "get" ( vthis, lowerP) with elab;
			lowerV := ret;
			ret := "get" ( vthis, upperP) with elab;
			upperV := ret;

			ret := "hasProperty" (vthis, upperP) with elab;
			upperE := ret;
			ret := "hasProperty" (vthis, lowerP) with elab;
			lowerE := ret;

			goto [lowerE and upperE] tt el1;

	tt:		ret := "put" (vthis, lowerP, upperV, true) with elab;
			ret := "put" (vthis, upperP, lowerV, true) with elab;
			goto inc;

	el1:	goto [upperE] ft el2;

	ft:		ret := "put" (vthis, lowerP, upperV, true) with elab;
			ret := "deleteProperty" (vthis, upperP, true) with elab;
			goto inc;

	el2:	goto [lowerE] tf inc;

	tf:		ret := "deleteProperty" (vthis, lowerP, true) with elab;
			ret := "put" (vthis, upperP, lowerV, true) with elab;

	inc:	lower := lower + 1;
			goto loop;

	end:	ret := vthis;

	rlab: return;
	elab: throw
};

(* *** SHIFT *** *)
proc AP_shift(xsc, vthis) {
			ret := "i__toObject" (vthis) with elab;
			vthis := ret;

			ret := "get" ( vthis, "length") with elab;
			ret := "i__toLength" (ret) with elab;
			len := ret;

			goto [len = 0] zero nz;

	zero:	ret := "put" (vthis, "length", 0, true) with elab;
			ret := undefined;
			goto rlab;

	nz:		ret := "get" ( vthis, "0") with elab;
			first := ret;

			k := 1;
	loop:	goto [k < len] less end;
	less:	ret := "i__toString" (k) with elab;
			from := ret;
			kk := k - 1;
			ret := "i__toString" (kk) with elab;
			to := ret;
			ret := "hasProperty" (vthis, from) with elab;
			goto [ret] t f;

	t:		ret := "get" ( vthis, from) with elab;
			ret := "put" (vthis, to, ret, true) with elab;
			goto inc;

	f:		ret := "deleteProperty" (vthis, to, true) with elab;
	inc:	k := k + 1;
			goto loop;

	end:	len := len - 1;
			ret := "i__toString" (len) with elab;
			ret := "deleteProperty" (vthis, ret, true) with elab;
			ret := "put" (vthis, "length", len, true) with elab;
			ret := first;

	rlab: return;
	elab: throw
};

(* *** SLICE *** *)
proc AP_slice(xsc, vthis, start, end) {
			ret := "i__toObject" (vthis) with elab;
			vthis := ret;

			ret := "get" ( vthis, "length") with elab;
			ret := "i__toLength" (ret) with elab;
			len := ret;

			ret := "i__toInteger" (start) with elab;
			rs := ret;

	if1:	goto [rs < 0] if1t if1f;
	if1t:	lrs := len + rs;
			goto [not (lrs < 0)] gr ls;
	gr:		k := lrs;
			goto if2;
	ls:		k := 0;
			goto if2;

	if1f:	goto [rs <= len] ls1 gr1;
	gr1:	k := len;
			goto if2;
	ls1:	k := rs;

	if2:	goto [end = undefined] if2t if2f;
	if2t:	re := len;
			goto if3;
	if2f:	ret := "i__toInteger" (end) with elab;
			re := ret;

	if3:	goto [re < 0] if3t if3f;

	if3t:	lre := len + re;
			goto [not (lre < 0)] gr2 ls2;
	gr2:	final := lre;
			goto setn;
	ls2:	final := 0;
			goto setn;

	if3f:	goto [re <= len] ls3 gr3;
	ls3:	final := re;
			goto setn;
	gr3:	final := len;

	setn:	n := 0;

            count := final - k;
            goto [final - k < 0] zero create;

    zero:   count := 0;

    create: ret := "Array_construct" (empty, empty, count) with elab;
			A := ret;

	loop:	goto [k < final] next end;

	next:	ret := "i__toString" (k) with elab;
			pk := ret;

			ret := "hasProperty" (vthis, pk) with elab;
			kpres := ret;
			goto [kpres] tt ff;

	tt:		ret := "get" ( vthis, pk) with elab;
			kval := ret;
			ret := "i__toString" (n) with elab;
			strn := ret;
			ret := "a__defineOwnProperty" (A, strn, {{ "d", kval, true, true, true }}, false) with elab;

	ff:		k := k + 1;
			n := n + 1;
			goto loop;

	end:	ret := A;

	rlab: return;
	elab: throw
};

(* *** UNSHIFT *** *)
proc AP_unshift() {
			arguments := args;
			vthis := l-nth (arguments, 1);

			ret := "i__toObject" (vthis) with elab;
			vthis := ret;

			ret := "get" ( vthis, "length") with elab;
			ret := "i__toLength" (ret) with elab;
			len := ret;
			k := len;

			num := l-len (arguments);
			argc := num - 2;

	loop1:	goto [not (k <= 0)] next1 end1;
	next1:	ret := k - 1;
			ret := "i__toString" (ret) with elab;
			from := ret;

			ret := k + argc;
			ret := ret - 1;
			ret := "i__toString" (ret) with elab;
			to := ret;

			ret := "hasProperty" (vthis, from) with elab;
			fromp := ret;

			goto [fromp] fpt fpf;

	fpt:	ret := "get" ( vthis, from) with elab;
			fromv := ret;
			ret := "put" (vthis, to, fromv, true) with elab;
			goto dec;

	fpf:	ret := "deleteProperty" (vthis, to, true) with elab;

	dec:	k := k - 1;
			goto loop1;

	end1:	j := 0;
			nm := 2;

	loop:	goto [nm < num] next end;
	next:	elem := l-nth(arguments, nm);
			ret := "i__toString" (j) with elab;
			strj := ret;
			ret := "put" (vthis, strj, elem, true) with elab;
			j := j + 1;
			nm := nm + 1;
			goto loop;

	end:	lac := len + argc;
			ret := "put" (vthis, "length", lac, true) with elab;
			ret := lac;

	rlab: return;
	elab: throw
};

(* *** SPLICE *** *)
proc AP_splice() {
			arguments := args;
			vthis := l-nth (arguments, 1);
			num := l-len (arguments);

			goto [num < 3] nstrt ystrt;
	nstrt:	start := undefined;
			goto dc;
	ystrt:	start := l-nth (arguments, 2);

	dc:		goto [num < 4] ndc ydc;
	ndc:	deleteCount := undefined;
			goto tobj;
	ydc:	deleteCount := l-nth (arguments, 3);

	tobj:	ret := "i__toObject" (vthis) with elab;
			vthis := ret;

			ret := "Array_construct" (empty, empty) with elab;
			A := ret;

			ret := "get" ( vthis, "length") with elab;
			ret := "i__toLength" (ret) with elab;
			len := ret;

			ret := "i__toInteger" (start) with elab;
			rs := ret;

			goto [rs < 0] ift iff;

	ift:	goto [(len + rs) > 0] rl1 rr1;
	rl1:	ret := len + rs;
			goto sync;
	rr1:	ret := 0;
			goto sync;

    iff:	goto [rs < len] rl2 rr2;
    rl2:	ret := rs;
    		goto sync;
    rr2:	ret := len;
	sync:	acs := ret;

			ret := "i__toInteger" (deleteCount) with elab;

			goto [ret > 0] ch1 rr3;
	rr3:	ret := 0;
	ch1:	goto [ret < (len - acs)] adc rr4;
	rr4:	ret := len - acs;
	adc:	adc := ret;

			k := 0;
	loop1:	goto [k < adc] next1 end1;
	next1:	ask := acs + k;
			ret := num_to_string ask;
			from := ret;
			ret := "hasProperty" (vthis, from) with elab;
			fromp := ret;
			goto [fromp] fpt fpf;

	fpt:	ret := "get" ( vthis, from) with elab;
			fromv := ret;
			ret := num_to_string k;
			strk := ret;
			ret := "a__defineOwnProperty" (A, strk, {{ "d", fromv, true, true, true }}, false) with elab;

	fpf:	k := k + 1;
			goto loop1;

	end1:	num := l-len (arguments);
			goto [(num - 4) > 0] rl5 rr5;
    rl5:    ret := num - 4;
            goto itemc;
	rr5:	ret := 0;
	itemc:	itemc := ret;
			ladcic := len - adc;
			ladcic := ladcic + itemc;

			goto [itemc < adc] less nless;

	less:	k := acs;
			ladc := len - adc;
	loop2:	goto [k < ladc] next2 end2;
	next2:	kadc := k + adc;
			ret := num_to_string kadc;
			from := ret;
			kic := k + itemc;
			ret := num_to_string kic;
			to := ret;
			ret := "hasProperty" (vthis, from) with elab;
			fromp := ret;
			goto [fromp] fptt fpff;

	fptt:	ret := "get" ( vthis, from) with elab;
			fromv := ret;
			ret := "put" (vthis, to, fromv, true) with elab;
			goto cont1;
	fpff:	ret := "deleteProperty" (vthis, to, true) with elab;
	cont1:	k := k + 1;
			goto loop2;

	end2:	k := len;

	loop3:	goto [not (k <= ladcic)] next3 end3;
	next3:	k1 := k - 1;
			ret := num_to_string k1;
			k1 := ret;
			ret := "deleteProperty" (vthis, k1, true) with elab;
			k := k - 1;
			goto loop3;

	nless:	goto [not (itemc <= adc)] more end3;

	more:	k := len - adc;
	loop4:	goto [not (k <= acs)] next4 end3;
	next4:	kadc1 := k + adc;
			kadc1 := kadc1 - 1;
			ret := num_to_string kadc1;
			from := ret;
			kic1 := k + itemc;
			kic1 := kic1 - 1;
			ret := num_to_string kic1;
			to := ret;
			ret := "hasProperty" (vthis, from) with elab;
			fromp := ret;
			goto [fromp] fpttt fpfff;
	fpttt:	ret := "get" ( vthis, from) with elab;
			fromv := ret;
			ret := "put" (vthis, to, fromv, true) with elab;
			goto dec;

	fpfff:	ret := "deleteProperty" (vthis, to, true) with elab;

	dec:	k := k - 1;
			goto loop4;

	end3:	k := acs;
			nm := 4;
	loop5:	goto [nm < num] next5 end5;

	next5:	elem := l-nth (arguments, nm);
			ret := num_to_string k;
			strk := ret;
			ret := "put" (vthis, strk, elem, true) with elab;
			k := k + 1;
			nm := nm + 1;
			goto loop5;

	end5:	ret := "put" (vthis, "length", ladcic, true) with elab;
			ret := A;

	rlab: return;
	elab: throw
};

(* *** INDEXOF *** *)
proc AP_indexOf (xsc, vthis, search_elem) {
          arguments := args;
          num := l-len (arguments);

          arr_obj := "i__toObject" (vthis) with elab;
          get_len := "get" (arr_obj, "length") with elab;
          len := "i__toLength" (get_len) with elab;

          goto [len = 0] neg1 next;

  next:	  goto [num > 3] nem em;

  em:     n := 0;
          goto nlen;

          (* Optional fromIndex argument *)
  nem:    fi := l-nth (arguments, 3);
          n := "i__toInteger" (fi) with elab;

  nlen:	  goto [(len <= n)] neg1 next2;

  next2:  goto [n < 0] lelse lif;

  lif:    k := m_abs n;
          goto loop;

  lelse:  k := m_abs n;
          k := len - k;
          goto [k < 0] zero loop;

  zero:	  k := 0;

  loop:	  goto [k < len] lp neg1;

  lp:     strk := "i__toString" (k) with elab;
          kpres := "hasProperty" (arr_obj, strk) with elab;

          goto [kpres] next3 end;

  next3:  elemk := "get" ( arr_obj, strk) with elab;

          strict_eq := "i__strictEquality" (search_elem, elemk) with elab;
          goto [strict_eq] r end;

  r:      ret_k := k;
          goto rlab;

  end:    k := k + 1;
          goto loop;

  neg1:   ret_neg_1 := -1;
  rlab:   PHI(ret: ret_k, ret_neg_1);
          return;

  elab:   PHI(ret: arr_obj, get_len, len, n, strk, kpres, elemk, strict_eq);
          throw
};

(* *** LASTINDEXOF *** *)
proc AP_lastIndexOf (xsc, vthis, search_elem) {
          arguments := args;
          num := l-len (arguments);

          arr_obj := "i__toObject" (vthis) with elab;
          get_len := "get" (arr_obj, "length") with elab;
          len := "i__toLength" (get_len) with elab;

          goto [len = 0] neg1 next;

  next:   goto [num > 3] nem em;

  em:     n := len - 1;
          goto nlen;

          (* Optional fromIndex argument *)
  nem:    fi := l-nth (arguments, 3);
          n := "i__toInteger" (fi) with elab;

  nlen:   goto [n < 0] lelse lif;
  lif:    len1 := len - 1;
          goto [n <= len1] ls gr;
  ls:     k := m_abs n;
          goto loop;
  gr:     k := len1;
          goto loop;

  lelse:  k := m_abs n;
          k := len - k;

  loop:   goto [not (k < 0)] lp neg1;
  lp:     strk := "i__toString" (k) with elab;
          kpres := "hasProperty" (arr_obj, strk) with elab;
          goto [kpres] tt ff;

  tt:     elemk := "get" (arr_obj, strk) with elab;
          strict_eq := "i__strictEquality" (search_elem, elemk) with elab;
          goto [strict_eq] r ff;
  r:      ret_k := k;
          goto rlab;

  ff:     k := k - 1;
          goto loop;

  neg1:   ret_neg_1 := -1;

  rlab:   PHI(ret: ret_k, ret_neg_1);
          return;
  elab:   PHI(ret: arr_obj, get_len, len, n, strk, kpres, elemk, strict_eq);
          throw
};

(* *** EVERY *** *)
proc AP_every(xsc, vthis, cbf) {
          arguments := args;
          num := l-len (arguments);

          arr_obj := "i__toObject" (vthis) with elab;

          get_len := "get" (arr_obj, "length") with elab;
          len := "i__toLength" (get_len) with elab;

          is_call := "i__isCallable" (cbf);
          goto [is_call] cont thrw;

          (* Check if optional thisArg is supplied at runtime *)
  cont:   goto [num > 3] def set_t;
  def:    def_t := l-nth (arguments, 3);
  set_t:  PHI(t: undefined, def_t);

          (* Call callbackfn on every element *)
          k := 0;
  loop:	  goto [k < len] next end;

  next:   pk := "i__toString" (k) with elab;
          kpres := "hasProperty" (arr_obj, pk) with elab;
          goto [kpres] tt ff;

  tt:     kval := "get" (arr_obj, pk) with elab;
          m := metadata(cbf);
          scp := [m, "@scope"];
          fun := [m, "@call"];
          tr := fun (scp, t, kval, k, arr_obj) with elab;
          tr_bool := "i__toBoolean" (tr) with elab;
          goto [tr_bool] ff retf;

  retf:   goto rlab;

  ff:     k := k + 1;
          goto loop;
          (* End of loop *)
  end:    skip;

  rlab:   PHI(ret: false, true);
          return;

  thrw:	  type_err := "TypeError" ();
  elab:   PHI(ret: arr_obj, get_len, len, pk, kpres, kval, tr, tr_bool, type_err);
          throw
};

(* *** SOME *** *)
proc AP_some(xsc, vthis, callbackfn) {
          arguments := args;
          num := l-len (arguments);

          arr_obj := "i__toObject" (vthis) with elab;
          get_len := "get" (arr_obj, "length") with elab;
          len := "i__toLength" (get_len) with elab;

          is_call := "i__isCallable" (callbackfn);
          goto [is_call] cont thrw;

          (* Check if optional thisArg is supplied at runtime *)
  cont:   goto [num > 3] def set_t;
  def:    def_t := l-nth (arguments, 3);
  set_t:  PHI(t: undefined, def_t);

          k := 0;
          (* Call callbackfn on every element *)
  loop:	  goto [k < len] next end;

  next:   pk := "i__toString" (k) with elab;
          kpres := "hasProperty" (arr_obj, pk) with elab;
          goto [kpres] tt ff;

  tt:     kval := "get" (arr_obj, pk) with elab;
          m := metadata(callbackfn);
          scp := [m, "@scope"];
          fun := [m, "@call"];
          tr := fun (scp, t, kval, k, arr_obj) with elab;
          tr_bool := "i__toBoolean" (tr) with elab;
          goto [tr_bool] done ff;

  done:   ret_true := true;
          goto rlab;

  ff:     k := k + 1;
          goto loop;
          (* End of loop *)
  end:    ret_false := false;

  rlab:   PHI(ret: ret_true, ret_false);
          return;

  thrw:	  type_err := "TypeError" ();
  elab:   PHI(ret: arr_obj, get_len, len, pk, kpres, kval, tr, tr_bool, type_err);
          throw
};

(* *** FOREACH *** *)
proc AP_forEach(xsc, vthis, callbackfn) {
          arguments := args;
          num := l-len (arguments);

          arr_obj := "i__toObject" (vthis) with elab;
          get_len := "get" (arr_obj, "length") with elab;
          len := "i__toLength" (get_len) with elab;

          is_call := "i__isCallable" (callbackfn);
          goto [is_call] cont thrw;

          (* Check if optional thisArg is supplied at runtime *)
  cont:   undef_t := undefined;
          goto [num > 3] def set_t;
  def:    def_t := l-nth (arguments, 3);
  set_t:  PHI(t: undef_t, def_t);

          start := 0;
  loop:   PHI(k: start, next_k);
          goto [k < len] next end;

  next:   pk := "i__toString" (k) with elab;
          kpres := "hasProperty" (arr_obj, pk) with elab;
          goto [kpres] tt ff;

  tt:     kval := "get" (arr_obj, pk) with elab;
          m := metadata(callbackfn);
          scp := [m, "@scope"];
          fun := [m, "@call"];
          ret_val := fun (scp, t, kval, k, arr_obj) with elab;

  ff:     next_k := k + 1;
          goto loop;

  end:    ret := undefined;
          return;

  thrw:   type_err := "TypeError" ();
  elab:   PHI(ret: arr_obj, get_len, len, pk, kpres, kval, ret_val, type_err);
          throw
};

(* *** MAP *** *)
proc AP_map(xsc, vthis, callbackfn) {
          arguments := args;
          num := l-len (arguments);

          arr_obj := "i__toObject" (vthis) with elab;
          get_len := "get" (arr_obj, "length") with elab;
          len := "i__toLength" (get_len) with elab;

          is_call := "i__isCallable" (callbackfn);
          goto [is_call] cont thrw;

          (* Check if optional thisArg is supplied at runtime *)
  cont:	  undef_t := undefined;
          goto [num > 3] def set_t;
  def:    def_t := l-nth (arguments, 3);
  set_t:  PHI(t: undef_t, def_t);

          new_arr := "Array_construct" (empty, empty, len) with elab;

          (* Loop start *)
          start := 0;
  loop:	  PHI(k: start, next_k);
          goto [k < len] next end;

  next:	  pk := "i__toString" (k) with elab;
          kpres := "hasProperty" (arr_obj, pk) with elab;
          goto [kpres] tt ff;

  tt:     kval := "get" (arr_obj, pk) with elab;
          m := metadata(callbackfn);
          scp := [m, "@scope"];
          fun := [m, "@call"];
          mapv := fun (scp, t, kval, k, arr_obj) with elab;
          ret_def := "a__defineOwnProperty" (new_arr, pk, {{ "d", mapv, true, true, true }}, false) with elab;

  ff:     next_k := k + 1;
          goto loop;
          (* Loop end *)
          (* Normal/ return *)
  end:    ret := new_arr;
          return;

          (* Error return *)
  thrw:   type_err := "TypeError" ();
  elab:   PHI(ret: arr_obj, get_len, len, new_arr, pk, kpres, kval, mapv, ret_def, type_err);
          throw
};

(* *** FILTER *** *)
proc AP_filter(xsc, vthis, callbackfn) {
          arguments := args;
          num := l-len (arguments);

          arr_obj := "i__toObject" (vthis) with elab;
          get_len := "get" (arr_obj, "length") with elab;
          len := "i__toLength" (get_len) with elab;

          is_call := "i__isCallable" (callbackfn);
          goto [is_call] cont thrw;

          (* Check if optional thisArg is supplied at runtime *)
  cont:	  undef_t := undefined;
          goto [num > 3] def set_t;
  def:    def_t := l-nth (arguments, 3);
  set_t:  PHI(t: undef_t, def_t);

  seta:   new_arr := "Array_construct" (empty, empty) with elab;

          (* Loop start *)
          start := 0;
          to_init := 0;
  loop:   PHI(k: start, next_k; to: to_init, next_to);
          goto [k < len] next end;

  next:   pk := "i__toString" (k) with elab;
          kpres := "hasProperty" (arr_obj, pk) with elab;
          goto [kpres] tt ff;

  tt:     kval := "get" (arr_obj, pk) with elab;
          m := metadata(callbackfn);
          scp := [m, "@scope"];
          fun := [m, "@call"];
          maybe_fret := fun (scp, t, kval, k, arr_obj) with elab;
          goto [maybe_fret = empty] set_fr phi_fr;
  set_fr: fr_undef := undefined;
  phi_fr: PHI(selected: maybe_fret, fr_undef);
          is_sel := "i__toBoolean" (selected) with elab;
          goto [is_sel] rett ff;

  rett:   strt := "i__toString" (to) with elab;
          ret_def := "a__defineOwnProperty" (new_arr, strt, {{ "d", kval, true, true, true }}, false) with elab;
          to_1 := to + 1;

  ff:     PHI(next_to: to, to, to_1);
          next_k := k + 1;
          goto loop;
          (* Loop end *)

          (* Normal return *)
  end:    ret := new_arr;
          return;

          (* Error return *)
  thrw:   ret := "TypeError" ();
  elab:   PHI(ret: arr_obj, get_len, len, new_arr, pk, kpres, kval, maybe_fret, is_sel, strt, ret_def, ret);
          throw
};

(* *** REDUCE *** *)
(** Section 15.4.4.21
  Array.prototype.reduce(callbackfn, [, initalValue])
  Parameters:
  -> First 3 parameters are JSIL procedure parameters.
  4. callbackfn: Function to call during the reduce operation
  5. Optional initialValue parameter.
  (Not SSA)
*)
proc AP_reduce(xsc, vthis, callbackfn) {
          arguments := args;
          num := l-len (arguments);

          arr_obj := "i__toObject" (vthis) with elab;
          get_len := "get" (arr_obj, "length") with elab;
          len := "i__toLength" (get_len) with elab;

          is_call := "i__isCallable" (callbackfn);
          goto [is_call] check thrw;

  check:  goto [(len = 0) and (num <= 3)] thrw set_k;

  set_k:  k := 0;
          (* Check if optional initialValue is supplied at runtime *)
          goto [num > 3] set_a lelse;
  set_a:  acc := l-nth (arguments, 3);
          goto loop2;

          (* Else clause comes first by algorithm *)
  lelse:  kpres := false;
          (* First Loop Start *)
  loop:   goto [(not kpres) and (k < len)] next1 end1;
  next1:  pk := "i__toString" (k) with elab;
          kpres := "hasProperty" (arr_obj, pk) with elab;
          goto [kpres] tt ff;

  tt:	    acc := "get" (arr_obj, pk) with elab;

  ff:     k := k + 1;
          goto loop;
          (* First Loop End *)

  end1:   goto [kpres] loop2 thrw;

          (* Second Loop Start *)
  loop2:  goto [k < len] next2 end;
  next2:  pk := "i__toString" (k) with elab;
          kpres := "hasProperty" (arr_obj, pk) with elab;
          goto [kpres] t f;

  t:      kval := "get" (arr_obj, pk) with elab;
          m := metadata(callbackfn);
          scp := [m, "@scope"];
          fun := [m, "@call"];
          acc := fun (scp, undefined, acc, kval, k, arr_obj) with elab;

  f:      k := k + 1;
          goto loop2;
          (* Second Loop End *)

  end:    ret := acc;
  rlab:   return;

  thrw:	  type_err := "TypeError" ();
  elab:   PHI(ret: arr_obj, get_len, len, pk, kpres, acc, pk, kpres, kval, acc, type_err);
          throw
};

(* *** REDUCERIGHT *** *)
(** Section 15.4.4.22
  Array.prototype.reduceRight(callbackfn, [, initalValue])
  Parameters:
  -> First 3 parameters are JSIL procedure parameters.
  4. callbackfn: Function to call during the reduce operation
  5. Optional initialValue parameter.
  (Not SSA)
*)
proc AP_reduceRight(xsc, vthis, callbackfn) {
          arguments := args;
          num := l-len (arguments);

          arr_obj := "i__toObject" (vthis) with elab;
          get_len := "get" (arr_obj, "length") with elab;
          len := "i__toLength" (get_len) with elab;

          is_call := "i__isCallable" (callbackfn);
          goto [is_call] check thrw;

  check:  goto [(len = 0) and (num <= 3)] thrw setk;

  setk:	  k := len - 1;
          goto [num > 3] set_a lelse;

  set_a:  acc := l-nth (arguments, 3);
          goto loop2;

  lelse:  kpres := false;

          (* First Loop Start *)
  loop:	  goto [(not kpres) and (0 <= k)] next1 end1;

  next1:  pk := "i__toString" (k) with elab;
          kpres := "hasProperty" (arr_obj, pk) with elab;
          goto [kpres] tt ff;

  tt:     acc := "get" (arr_obj, pk) with elab;

  ff:     k := k - 1;
          goto loop;
          (* First Loop End *)
  end1:   goto [kpres] loop2 thrw;

          (* Second Loop Start *)
  loop2:  goto [not (k < 0)] next2 end;

  next2:  pk := "i__toString" (k) with elab;
          kpres := "hasProperty" (arr_obj, pk) with elab;
          goto [kpres] t f;

  t:      kval := "get" (arr_obj, pk) with elab;
          m := metadata(callbackfn);
          scp := [m, "@scope"];
          fun := [m, "@call"];
          acc := fun (scp, undefined, acc, kval, k, arr_obj) with elab;

  f:      k := k - 1;
          goto loop2;
          (* Second Loop End *)
          (* Normal return *)
  end:    ret := acc;
  rlab:   return;

          (* Error return *)
  thrw:	  type_err := "TypeError" ();
  elab:   PHI(ret: arr_obj, get_len, len, pk, kpres, acc, pk, kpres, kval, acc, type_err);
          throw
};

(* *** SORT *** *)
proc AP_sort(xsc, vthis, compfn) {
          ret := "i__toObject" (vthis) with elab;
          vthis := ret;

          ret := "get" ( vthis, "length") with elab;
          ret := "i__toLength" (ret) with elab;
          len := ret;

  (* 4 special conditions for implementation defined sort could be checked, maybe TODO *)

  (* check if vthis is sparse *)
  cs:     i := 0;
  cslp:	  goto [i < len] check done;

  check:  ret := "i__toString" (i) with elab;
          stri := ret;
          ret := "getOwnProperty" (vthis, stri) with elab;
          elem := ret;
          goto [elem = undefined] spt spf;
  spt:    spar := true;
          goto otw;

  spf:    i := i + 1;
          goto cslp;

  done:	  spar := false;
  (* end of sparse check *)

  otw:    goto [len < 2] fin cont;

  cont:	  ret := "Array_construct" (empty, empty) with elab;
          stack := ret;

          ret := "AP_push" (empty, stack, 0);
          len1 := len - 1;
          ret := "AP_push" (empty, stack, len1);

          size := 1;

  while1: goto [not (size <= 0)] ltz fin;

  ltz:    ret := "AP_pop" (empty, stack);
          end := ret;
          ret := "i__toString" (end) with elab;
          strend := ret;
          ret := "AP_pop" (empty, stack);
          start := ret;

          size := size - 1;
          l := start;
          curr := start;

  while2:	goto [curr < end] next1 end1;

  next1:  ret := "a__sortCompare" (curr, end, compfn, vthis) with elab;
          goto [ret < 0] less nless;

  less:	  ret := "i__toString" (l) with elab;
          strl := ret;
          ret := "i__toString" (curr) with elab;
          strcurr := ret;
          ret := "get" (vthis, strcurr) with elab;
          tmp := ret;
          ret := "hasProperty" (vthis, strl) with elab;
          goto [ret] iina niina;

  (* swap l and current *)
  iina:	  ret := "get" (vthis, strl) with elab;
          ret := "put" (vthis, strcurr, ret, true) with elab;
          ret := "put" (vthis, strl, tmp, true) with elab;
          goto incl;

  niina:  ret := "put" (vthis, strl, tmp, true) with elab;
          ret := "deleteProperty" (vthis, strcurr, true) with elab;

  incl:   l := l + 1;

  nless:  curr := curr + 1;
          goto while2;

  end1:	  goto [l < end] sw nsw;

  sw:     ret := "i__toString" (l) with elab;
          strl := ret;
          ret := "get" (vthis, strend) with elab;
          el := ret;
          ret := "hasProperty" (vthis, strl) with elab;
          goto [ret] ina nina;

  ina:    ret := "get" (vthis, strl) with elab;
          ret := "put" (vthis, strend, ret, true) with elab;
          ret := "put" (vthis, strl, el, true) with elab;
          goto nsw;

  nina:   ret := "hasProperty" (vthis, strend) with elab;
          goto [ret] del nsw;

  del:    ret := "put" (vthis, strl, el, true) with elab;
          ret := "deleteProperty" (vthis, strend, true) with elab;

  nsw:    ll := l + 1;
          goto [not (end <= ll)] more nmore;

  more:	  ret := "AP_push" (empty, stack, ll);
          ret := "AP_push" (empty, stack, end);
          size := size + 1;

  nmore:  l := l - 1;
          goto [not (l <= start)] ifs while1;

  ifs:    ret := "AP_push" (empty, stack, start);
          ret := "AP_push" (empty, stack, l);
          size := size + 1;
          goto while1;

  fin:    ret := vthis;
  rlab:   return;

  thrw:   ret := "TypeError" ();
  elab:   throw
};

(* *** SORTCOMPARE *** *)
proc a__sortCompare(j, k, compfn, vthis) {

			ret := "i__toString" (j) with elab;
			strj := ret;
			ret := "i__toString" (k) with elab;
			strk := ret;
			ret := "hasProperty" (vthis, strj) with elab;
			hasj := ret;
			ret := "hasProperty" (vthis, strk) with elab;
			hask := ret;

			goto [hasj] yesj noj;

	yesj:	goto [hask] cmp nok;

	nok:	ret := -1;
			goto rlab;

	noj:	goto [hask]	yesk nojk;

	yesk:	ret := 1;
			goto rlab;

	nojk:	ret := 0;
			goto rlab;

	cmp:	ret := "get" ( vthis, strj) with elab;
			x := ret;
			ret := "get" ( vthis, strk) with elab;
			y := ret;
			goto [(x = undefined) and (y = undefined)] nojk xx;
	xx:		goto [x = undefined] yesk yy;
	yy:		goto [y = undefined] nok cont;
	cont:	goto [compfn = undefined] cont1 lif;

	lif:	ret := "i__isCallable" (compfn);
			goto [ret] call thrw;
	call:	m := metadata(compfn);
			scp := [m, "@scope"];
			fun := [m, "@call"];
			ret := fun (scp, undefined, x, y) with elab;
			goto rlab;

	cont1:	ret := "i__toString" (x) with elab;
			strx := ret;
			ret := "i__toString" (y) with elab;
			stry := ret;
			goto [strx s< stry] nok xy;
	xy:		goto [not (strx = stry)] yesk nojk;

	rlab: return;

	thrw:	ret := "TypeError" ();
	elab: throw
};
